const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,c,l)=>t(((e,n)=>{const c=t(e),l=n.length;let a=0,s=0;for(;a<c&&(r(e[a])&&(e[a]=n[s++]),s!=l);a++);for(;s<l;s++)e[c+s]=n[s];return e})(c,l))<e.length?(...r)=>n(e,c,r):e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(c)),c=e=>(...r)=>n(e,{},r),l=e=>typeof e,a=e=>null===e,s=e=>"number"==l(e),o=e=>"object"==l(e)&&!a(e),u=c((e,r)=>{if("object"==l(e)&&"object"==l(r)){if(a(e)||a(r))return e===r;for(let t of[e,r])for(let n in t)if(!u(e[n],r[n]))return!1}return e===r}),i=c((e,r,t,n)=>e(n)?r(n):t(n)),f=c((e,r,t)=>i(e,r,O,t)),b=(...e)=>r=>{for(let t=h(e)-1;t>-1;t--)r=e[t](r);return r},j=e=>c((r,t)=>e(t,r)),y=e=>a(e)||(e=>void 0===e)(e),h=e=>e.length,g=e=>()=>e,O=e=>e,w=e=>e.trim(),A=e=>e[0],p=e=>e.slice(1),d=e=>e[e.length-1],m=e=>r=>!e(r),k=e=>Object.keys(e),v=e=>Object.values(e),N=e=>Object.entries(e),P=e=>r=>(e(r),r),x=(e,r="log")=>P(t=>console[r](e,t)),C=c((e,r,t)=>t.slice(e,s(r)?r:1/0)),E=c((e,r,t)=>({...t,[e]:r})),S=c((e,r)=>r[e]),U=c((e,r,t)=>i(h,b(i(y,g(e),t=>U(e,C(1,null,r),t)),j(S)(t),A),g(t))(r)),q=U(void 0),z=e=>{switch(l(e)){case"object":switch(J(e)){case"Null":return e;case"Array":return G(z,e);case"Object":const r={};for(let t in e)r[t]=z(e[t]);return r}default:return e}},B=c((e,r,t)=>t.reduce(e,z(r))),D=e=>B((e,r)=>E(...r,e),{},e),F=c((e,r)=>r.join(e)),G=c((e,r)=>r.map(e)),H=c((e,r)=>r.forEach(e)),I=c((e,r,t)=>r(t)&&e(t)),J=e=>{const r=l(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":a(e)?"Null":"Object":r[0].toUpperCase()+r.slice(1)},K=e=>{switch(J(e)){case"String":return""==e;case"Array":return 0==h(e);case"Null":return!1;case"Object":return 0==h(Object.keys(e));default:return!1}},L=c((e,r,t)=>t.replace(e,r)),M=c((e,r)=>i(b(u("Array"),J),r=>r.filter(e),b(D,M(([r,t])=>e(t,r)),N))(r)),Q=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},R=c((e,r)=>Object.assign({},e,r)),T=c((e,r)=>{for(let t in r)switch(J(r[t])){case"Array":case"Object":if(o(r[t])){T(e[t],r[t]);break}default:e[t]=r[t]}return e}),V=c((e,r)=>b(D,M(m(y)),G(([r,t])=>a(e[r])?null:[e[r]||r,t]),N)(r)),W=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c((r,t)=>e(r,t,0))})(),X=e=>Promise.all(e),Y=c((e,r)=>Promise.all(r.map(e))),Z=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})();export{e as __,g as always,E as assoc,I as both,z as clone,m as complement,b as compose,Z as composeAsync,c as curry,u as equals,x as explore,M as filter,j as flip,H as forEach,Y as forEachAsync,W as forEachSerial,D as fromPairs,A as head,O as identity,i as ifElse,K as isEmpty,y as isNil,F as join,k as keys,d as last,h as length,G as map,V as mapKeys,Q as memoize,T as mergeDeep,R as mergeShallow,q as path,U as pathOr,S as prop,B as reduce,L as replace,C as slice,p as tail,P as tap,N as toPairs,w as trim,J as type,v as values,X as waitAll,f as when};
