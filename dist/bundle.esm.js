const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,n)=>{const c=t(e),l=n.length,a={};let s=0,o=0;for(;s<c;s++)a[s]=r(e[s])&&o<l?n[o++]:e[s];for(;o<l;o++)a[c+o]=n[o];return a},c=(e,r,l)=>{const a=t(r),s=e.length-a-l.length;return s<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,l)),...l.slice(-s)):(...t)=>c(e,n(r,l),t)},l=e=>(...r)=>c(e,{},r),a=e=>typeof e,s=e=>null===e,o=e=>"number"==a(e),u=e=>"object"==a(e)&&!s(e),i=l((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(s(e)||s(r))return e===r;for(let t of[e,r])for(let n in t)if(!i(e[n],r[n]))return!1}return e===r}),f=l((e,r,t,n)=>e(n)?r(n):t(n)),b=l((e,r,t)=>f(e,r,w,t)),j=(...e)=>r=>{for(let t=g(e)-1;t>-1;t--)r=e[t](r);return r},y=e=>l((r,t)=>e(t,r)),h=e=>s(e)||(e=>void 0===e)(e),g=e=>e.length,O=e=>()=>e,w=e=>e,A=e=>e.trim(),p=e=>e[0],d=e=>e.slice(1),m=e=>e[e.length-1],k=e=>r=>!e(r),v=e=>Object.keys(e),N=e=>Object.values(e),P=e=>Object.entries(e),x=e=>r=>(e(r),r),C=(e,r="log")=>x(t=>console[r](e,t)),E=l((e,r,t)=>t.slice(e,o(r)?r:1/0)),S=l((e,r,t)=>({...t,[e]:r})),U=l((e,r)=>r[e]),q=l((e,r,t)=>f(g,j(f(h,O(e),t=>q(e,E(1,null,r),t)),y(U)(t),p),O(t))(r)),z=q(void 0),B=e=>{switch(a(e)){case"object":switch(L(e)){case"Null":return e;case"Array":return I(B,e);case"Object":const r={};for(let t in e)r[t]=B(e[t]);return r}default:return e}},D=l((e,r)=>F((e,t)=>e[t]=r[t],{},e)),F=l((e,r,t)=>t.reduce(e,B(r))),G=e=>F((e,r)=>S(...r,e),{},e),H=l((e,r)=>r.join(e)),I=l((e,r)=>r.map(e)),J=l((e,r)=>r.forEach(e)),K=l((e,r,t)=>r(t)&&e(t)),L=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":s(e)?"Null":"Object":r[0].toUpperCase()+r.slice(1)},M=e=>{switch(L(e)){case"String":return""==e;case"Array":return 0==g(e);case"Null":return!1;case"Object":return 0==g(Object.keys(e));default:return!1}},Q=l((e,r,t)=>t.replace(e,r)),R=l((e,r)=>f(j(i("Array"),L),r=>r.filter(e),j(G,R(([r,t])=>e(t,r)),P))(r)),T=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},V=l((e,r)=>Object.assign({},e,r)),W=l((e,r)=>{for(let t in r)switch(L(r[t])){case"Array":case"Object":if(u(r[t])){W(e[t],r[t]);break}default:e[t]=r[t]}return e}),X=l((e,r)=>j(G,R(k(h)),I(([r,t])=>s(e[r])?null:[e[r]||r,t]),P)(r)),Y=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return l((r,t)=>e(r,t,0))})(),Z=e=>Promise.all(e),$=l((e,r)=>Promise.all(r.map(e))),_=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})();export{e as __,O as always,S as assoc,K as both,B as clone,k as complement,j as compose,_ as composeAsync,l as curry,i as equals,C as explore,R as filter,y as flip,J as forEach,$ as forEachAsync,Y as forEachSerial,G as fromPairs,p as head,w as identity,f as ifElse,M as isEmpty,h as isNil,H as join,v as keys,m as last,g as length,I as map,X as mapKeys,T as memoize,W as mergeDeep,V as mergeShallow,z as path,q as pathOr,D as pick,U as prop,F as reduce,Q as replace,E as slice,d as tail,x as tap,P as toPairs,A as trim,L as type,N as values,Z as waitAll,b as when};
