const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,n)=>{const l=t(e),c=n.length,a={};let s=0,u=0;for(;s<l;s++)a[s]=r(e[s])&&u<c?n[u++]:e[s];for(;u<c;u++)a[l+u]=n[u];return a},l=(e,r,c)=>{const a=e.length-t(r)-c.length;return a<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,c)),...c.slice(-a)):(...t)=>l(e,n(r,c),t)},c=e=>(...r)=>e.length>r.length?l(e,{},r):e(...r),a=e=>typeof e,s=e=>null===e,u=e=>"number"==a(e),o=e=>"object"==a(e)&&!s(e),i=c((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(s(e)||s(r))return e===r;for(let t of[e,r])for(let n in t)if(!i(e[n],r[n]))return!1}return e===r}),f=c((e,r,t,n)=>e(n)?r(n):t(n)),b=c((e,r,t)=>f(e,r,N,t)),j=(...e)=>r=>{for(let t=k(e)-1;t>-1;t--)r=e[t](r);return r},h=c((e,r)=>r[e]),y=c((e,r)=>r.includes(e)),g=c((e,r,t)=>t.slice(e,u(r)?r:1/0)),O=h(0),w=g(1,null),A=c((e,r)=>e+r),d=c((e,r)=>r-e),p=e=>c((r,t)=>e(t,r)),m=e=>s(e)||(e=>void 0===e)(e),k=e=>e.length,v=e=>()=>e,N=e=>e,P=e=>e.trim(),x=e=>e[k(e)-1],C=e=>r=>!e(r),E=e=>Object.keys(e),S=e=>Object.values(e),U=e=>Object.entries(e),q=e=>r=>(e(r),r),z=(e,r="log")=>q(t=>console[r](e,t)),B=c((e,r,t)=>({...t,[e]:r})),D=c((e,r)=>r[e]),F=c((e,r,t)=>f(k,j(f(m,v(e),t=>F(e,g(1,null,r),t)),p(D)(t),O),v(t))(r)),G=F(void 0),H=e=>{switch(a(e)){case"object":switch(V(e)){case"Null":return e;case"Array":return Q(H,e);case"Object":const r={};for(let t in e)r[t]=H(e[t]);return r}default:return e}},I=c((e,r,t)=>t.reduce(e,H(r))),J=c((e,r)=>I((e,t)=>e[t]=r[t],{},e)),K=c((e,r)=>Y((r,t)=>!y(t,e),r)),L=e=>I((e,r)=>B(...r,e),{},e),M=c((e,r)=>r.join(e)),Q=c((e,r)=>r.map(e)),R=c((e,r)=>r.forEach(e)),T=c((e,r,t)=>r(t)&&e(t)),V=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":s(e)?"Null":"Object":r[0].toUpperCase()+r.slice(1)},W=e=>{switch(V(e)){case"String":return""==e;case"Array":return 0==k(e);case"Null":return!1;case"Object":return 0==k(Object.keys(e));default:return!1}},X=c((e,r,t)=>t.replace(e,r)),Y=c((e,r)=>f(j(i("Array"),V),r=>r.filter(e),j(L,Y(([r,t])=>e(t,r)),U))(r)),Z=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},$=c((e,r)=>Object.assign({},e,r)),_=c((e,r)=>{for(let t in r)switch(V(r[t])){case"Array":case"Object":if(o(r[t])){_(e[t],r[t]);break}default:e[t]=r[t]}return e}),ee=c((e,r)=>j(L,Y(C(m)),Q(([r,t])=>s(e[r])?null:[e[r]||r,t]),U)(r)),re=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c((r,t)=>e(r,t,0))})(),te=e=>Promise.all(e),ne=c((e,r)=>Promise.all(r.map(e))),le=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})();export{e as __,A as add,v as always,B as assoc,T as both,H as clone,C as complement,j as compose,le as composeAsync,c as curry,i as equals,z as explore,Y as filter,p as flip,R as forEach,ne as forEachAsync,re as forEachSerial,L as fromPairs,O as head,N as identity,f as ifElse,y as includes,W as isEmpty,m as isNil,M as join,E as keys,x as last,k as length,Q as map,ee as mapKeys,Z as memoize,_ as mergeDeep,$ as mergeShallow,h as nth,K as omit,G as path,F as pathOr,J as pick,D as prop,I as reduce,X as replace,g as slice,d as subtract,w as tail,q as tap,U as toPairs,P as trim,V as type,S as values,te as waitAll,b as when};
