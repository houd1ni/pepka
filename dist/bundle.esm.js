const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,n)=>{const c=t(e),l=n.length,a={};let o=0,s=0;for(;o<c;o++)a[o]=r(e[o])&&s<l?n[s++]:e[o];for(;s<l;s++)a[c+s]=n[s];return a},c=(e,r,l)=>{const a=e.length-t(r)-l.length;return a<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,l)),...l.slice(-a)):(...t)=>c(e,n(r,l),t)},l=e=>(...r)=>e.length>r.length?c(e,{},r):e(...r),a=e=>typeof e,o=e=>null===e,s=e=>"number"==a(e),u=e=>"object"==a(e)&&!o(e),i=l((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(o(e)||o(r))return e===r;for(let t of[e,r])for(let n in t)if(!i(e[n],r[n]))return!1}return e===r}),f=l((e,r,t,n)=>e(n)?r(n):t(n)),b=l((e,r,t)=>f(e,r,C,t)),j=(...e)=>r=>{for(let t=N(e)-1;t>-1;t--)r=e[t](r);return r},h=l((e,r)=>r[e]),y=l((e,r)=>r.includes(e)),g=l((e,r,t)=>t.slice(e,s(r)?r:1/0)),d=e=>e.toLowerCase(),w=e=>e.toUpperCase(),O=h(0),A=g(1,null),p=l((e,r)=>e+r),m=l((e,r)=>r-e),k=e=>l((r,t)=>e(t,r)),v=e=>o(e)||(e=>void 0===e)(e),N=e=>e.length,x=e=>()=>e,C=e=>e,P=e=>e.trim(),E=e=>e[N(e)-1],I=e=>!e,L=e=>r=>I(e(r)),S=e=>Object.keys(e),U=e=>Object.values(e),q=e=>Object.entries(e),z=e=>r=>(e(r),r),B=l((e,r)=>r>e),D=l((e,r)=>r<e),F=l((e,r)=>r>=e),G=l((e,r)=>r<=e),H=l((e,r)=>r.findIndex(e)),J=(e,r="log")=>z(t=>console[r](e,t)),K=l((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)}),M=l((e,r,t)=>({...t,[e]:r})),Q=l((e,r)=>r[e]),R=l((e,r,t)=>f(N,j(f(v,x(e),t=>R(e,g(1,null,r),t)),k(Q)(t),O),x(t))(r)),T=R(void 0),V=e=>{switch(a(e)){case"object":switch(te(e)){case"Null":return e;case"Array":return _(V,e);case"Object":const r={};for(let t in e)r[t]=V(e[t]);return r}default:return e}},W=l((e,r,t)=>t.reduce(e,V(r))),X=l((e,r)=>W((e,t)=>e[t]=r[t],{},e)),Y=l((e,r)=>le((r,t)=>!y(t,e),r)),Z=e=>W((e,r)=>M(...r,e),{},e),$=l((e,r)=>r.join(e)),_=l((e,r)=>r.map(e)),ee=l((e,r)=>r.forEach(e)),re=l((e,r,t)=>r(t)&&e(t)),te=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":o(e)?"Null":"Object":w(r[0])+r.slice(1)},ne=e=>{switch(te(e)){case"String":return""==e;case"Array":return 0==N(e);case"Null":return!1;case"Object":return 0==N(Object.keys(e));default:return!1}},ce=l((e,r,t)=>t.replace(e,r)),le=l((e,r)=>f(j(i("Array"),te),r=>r.filter(e),j(Z,le(([r,t])=>e(t,r)),q))(r)),ae=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},oe=l((e,r)=>Object.assign({},e,r)),se=l((e,r)=>{for(let t in r)switch(te(r[t])){case"Array":case"Object":if(u(e[t])){se(e[t],r[t]);break}default:e[t]=r[t]}return e}),ue=l((e,r)=>j(Z,le(L(v)),_(([r,t])=>o(e[r])?null:[e[r]||r,t]),q)(r)),ie=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return l((r,t)=>e(r,t,0))})(),fe=e=>Promise.all(e),be=l((e,r)=>Promise.all(r.map(e))),je=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})(),he=C,ye=C,ge=C;export{e as __,p as add,x as always,M as assoc,re as both,V as clone,L as complement,j as compose,je as composeAsync,K as cond,l as curry,ge as echo,i as equals,J as explore,le as filter,H as findIndex,k as flip,ee as forEach,be as forEachAsync,ie as forEachSerial,Z as fromPairs,B as gt,F as gte,O as head,C as identity,f as ifElse,y as includes,ne as isEmpty,v as isNil,$ as join,S as keys,E as last,N as length,D as lt,G as lte,_ as map,ue as mapKeys,ae as memoize,se as mergeDeep,oe as mergeShallow,he as mirror,I as not,h as nth,Y as omit,T as path,R as pathOr,X as pick,Q as prop,W as reduce,ye as reflect,ce as replace,g as slice,m as subtract,A as tail,z as tap,d as toLower,q as toPairs,w as toUpper,P as trim,te as type,U as values,fe as waitAll,b as when};
