const e=function(){},r=r=>r===e,t=(e,t=!1)=>{let n=0;for(let c in e)(t||!r(e[c]))&&n++;return n},n=(e,n)=>{const c=t(e,!0),l=n.length,a={};let s=0,o=0;for(;s<c;s++)a[s]=r(e[s])&&o<l?n[o++]:e[s];for(;o<l;o++)a[c+o]=n[o];return a},c=(e,r,l)=>e.length-t(r)-t(l)<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,l))):(...t)=>c(e,n(r,l),t),l=e=>(...r)=>e.length>t(r)?c(e,{},r):e(...r),a=e=>typeof e,s=e=>null===e,o=e=>"number"==a(e),u=(e,r)=>(r.push(e),r),i=l((e,r,t)=>(t[e]=r,t)),f=l((e,r,t)=>t.reduce(e,r)),b=l((e,r)=>{for(let n in r)switch(fe(r[n])){case"Array":case"Object":if(t=e[n],"object"==a(t)&&!s(t)){b(e[n],r[n]);break}default:e[n]=r[n]}var t;return e}),j=l((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(s(e)||s(r))return e===r;for(let t of[e,r])for(let n in t)if(!j(e[n],r[n]))return!1}return e===r}),y=l((e,r,t,n)=>e(n)?r(n):t(n)),h=l((e,r,t)=>y(e,r,L,t)),d=(...e)=>r=>{for(let t=E(e)-1;t>-1;t--)r=e[t](r);return r},g=l((e,r)=>e.bind(r)),p=l((e,r)=>r[e]),w=l((e,r)=>r.includes(e)),O=l((e,r,t)=>t.slice(e,o(r)?r:1/0)),A=e=>e.toLowerCase(),m=e=>e.toUpperCase(),v=p(0),k=O(1,null),N=l((e,r)=>e+r),x=l((e,r)=>r-e),C=e=>l((r,t)=>e(t,r)),P=e=>s(e)||(e=>void 0===e)(e),E=e=>e.length,I=e=>()=>e,L=e=>e,S=e=>e.trim(),U=e=>e[E(e)-1],q=e=>!e,z=e=>r=>q(e(r)),B=e=>Object.keys(e),D=e=>Object.values(e),F=e=>Object.entries(e),G=l((e,r)=>(e(r),r)),H=(e,r)=>[...r,e],J=(e,r)=>r.split(e),K=I(!0),M=I(!1),Q=l((e,r)=>e>r),R=l((e,r)=>e<r),T=l((e,r)=>r>=e),V=l((e,r)=>r<=e),W=l((e,r)=>r.findIndex(e)),X=(e,r="log")=>G(t=>console[r](e,t)),Y=l((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)}),Z=l((e,r,t)=>({...t,[e]:r})),$=l((e,r)=>r[e]),_=l((e,r,t)=>y(E,d(y(P,I(e),t=>_(e,O(1,null,r),t)),C($)(t),v),I(t))(r)),ee=_(void 0),re=e=>{switch(a(e)){case"object":switch(fe(e)){case"Null":return e;case"Array":return oe(re,e);case"Object":const r={};for(let t in e)r[t]=re(e[t]);return r}default:return e}},te=l((e,r,t)=>f(e,re(r),t)),ne=l((e,r)=>ye(e,r)),ce=l((e,r)=>ye((r,t)=>w(t,e),r)),le=l((e,r)=>ye((r,t)=>!w(t,e),r)),ae=e=>te((e,r)=>Z(...r,e),{},e),se=l((e,r)=>r.join(e)),oe=l((e,r)=>r.map(e)),ue=l((e,r)=>r.forEach(e)),ie=l((e,r,t)=>r(t)&&e(t)),fe=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":s(e)?"Null":"Object":m(r[0])+r.slice(1)},be=e=>{switch(fe(e)){case"String":return""==e;case"Array":return 0==E(e);case"Null":return!1;case"Object":return 0==E(Object.keys(e));default:return!1}},je=l((e,r,t)=>t.replace(e,r)),ye=l((e,r)=>y(d(j("Array"),fe),r=>r.filter(e),d(ae,ye(([r,t])=>e(t,r)),F))(r)),he=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},de=l((e,r)=>Object.assign({},e,r)),ge=l((e,r)=>b(re(e),r)),pe=l((e,r)=>d(ae,ye(z(P)),oe(([r,t])=>s(e[r])?null:[e[r]||r,t]),F)(r)),we=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return l((r,t)=>e(r,t,0))})(),Oe=e=>Promise.all(e),Ae=l((e,r)=>Promise.all(r.map(e))),me=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})(),ve=L,ke=L,Ne=L;export{M as F,K as T,e as __,N as add,I as always,H as append,Z as assoc,g as bind,ie as both,re as clone,z as complement,d as compose,me as composeAsync,Y as cond,l as curry,Ne as echo,j as equals,X as explore,ye as filter,W as findIndex,C as flip,ue as forEach,Ae as forEachAsync,we as forEachSerial,ae as fromPairs,Q as gt,T as gte,v as head,L as identity,y as ifElse,w as includes,be as isEmpty,P as isNil,se as join,B as keys,U as last,E as length,R as lt,V as lte,oe as map,pe as mapKeys,he as memoize,ge as mergeDeep,de as mergeShallow,ve as mirror,q as not,p as nth,le as omit,ee as path,_ as pathOr,ce as pick,ne as pickBy,$ as prop,u as qappend,i as qassoc,b as qmergeDeep,f as qreduce,te as reduce,ke as reflect,je as replace,O as slice,J as split,x as subtract,k as tail,G as tap,A as toLower,F as toPairs,m as toUpper,S as trim,fe as type,D as values,Oe as waitAll,h as when};
