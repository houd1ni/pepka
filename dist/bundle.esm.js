const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,n)=>{const l=t(e),c=n.length,a={};let s=0,o=0;for(;s<l;s++)a[s]=r(e[s])&&o<c?n[o++]:e[s];for(;o<c;o++)a[l+o]=n[o];return a},l=(e,r,c)=>{const a=e.length-t(r)-c.length;return a<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,c)),...c.slice(-a)):(...t)=>l(e,n(r,c),t)},c=e=>(...r)=>e.length>r.length?l(e,{},r):e(...r),a=e=>typeof e,s=e=>null===e,o=e=>"number"==a(e),u=e=>"object"==a(e)&&!s(e),i=c((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(s(e)||s(r))return e===r;for(let t of[e,r])for(let n in t)if(!i(e[n],r[n]))return!1}return e===r}),f=c((e,r,t,n)=>e(n)?r(n):t(n)),b=c((e,r,t)=>f(e,r,C,t)),j=(...e)=>r=>{for(let t=k(e)-1;t>-1;t--)r=e[t](r);return r},h=c((e,r)=>r[e]),y=c((e,r)=>r.includes(e)),g=c((e,r,t)=>t.slice(e,o(r)?r:1/0)),p=h(0),w=g(1,null),O=c((e,r)=>e+r),A=c((e,r)=>r-e),d=e=>c((r,t)=>e(t,r)),m=e=>s(e)||(e=>void 0===e)(e),k=e=>e.length,v=e=>()=>e,C=e=>e,N=e=>e.trim(),P=e=>e[k(e)-1],U=e=>r=>!e(r),x=e=>Object.keys(e),E=e=>Object.values(e),L=e=>Object.entries(e),S=e=>r=>(e(r),r),q=(e,r="log")=>S(t=>console[r](e,t)),z=c((e,r,t)=>({...t,[e]:r})),B=c((e,r)=>r[e]),D=c((e,r,t)=>f(k,j(f(m,v(e),t=>D(e,g(1,null,r),t)),d(B)(t),p),v(t))(r)),F=D(void 0),G=e=>{switch(a(e)){case"object":switch(X(e)){case"Null":return e;case"Array":return T(G,e);case"Object":const r={};for(let t in e)r[t]=G(e[t]);return r}default:return e}},H=e=>e.toLowerCase(),I=e=>e.toUpperCase(),J=c((e,r,t)=>t.reduce(e,G(r))),K=c((e,r)=>J((e,t)=>e[t]=r[t],{},e)),M=c((e,r)=>$((r,t)=>!y(t,e),r)),Q=e=>J((e,r)=>z(...r,e),{},e),R=c((e,r)=>r.join(e)),T=c((e,r)=>r.map(e)),V=c((e,r)=>r.forEach(e)),W=c((e,r,t)=>r(t)&&e(t)),X=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":s(e)?"Null":"Object":r[0].toUpperCase()+r.slice(1)},Y=e=>{switch(X(e)){case"String":return""==e;case"Array":return 0==k(e);case"Null":return!1;case"Object":return 0==k(Object.keys(e));default:return!1}},Z=c((e,r,t)=>t.replace(e,r)),$=c((e,r)=>f(j(i("Array"),X),r=>r.filter(e),j(Q,$(([r,t])=>e(t,r)),L))(r)),_=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},ee=c((e,r)=>Object.assign({},e,r)),re=c((e,r)=>{for(let t in r)switch(X(r[t])){case"Array":case"Object":if(u(r[t])){re(e[t],r[t]);break}default:e[t]=r[t]}return e}),te=c((e,r)=>j(Q,$(U(m)),T(([r,t])=>s(e[r])?null:[e[r]||r,t]),L)(r)),ne=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c((r,t)=>e(r,t,0))})(),le=e=>Promise.all(e),ce=c((e,r)=>Promise.all(r.map(e))),ae=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})(),se=C,oe=C;export{e as __,O as add,v as always,z as assoc,W as both,G as clone,U as complement,j as compose,ae as composeAsync,c as curry,oe as echo,i as equals,q as explore,$ as filter,d as flip,V as forEach,ce as forEachAsync,ne as forEachSerial,Q as fromPairs,p as head,C as identity,f as ifElse,y as includes,Y as isEmpty,m as isNil,R as join,x as keys,P as last,k as length,T as map,te as mapKeys,_ as memoize,re as mergeDeep,ee as mergeShallow,se as mirror,h as nth,M as omit,F as path,D as pathOr,K as pick,B as prop,J as reduce,Z as replace,g as slice,A as subtract,w as tail,S as tap,H as toLower,L as toPairs,I as toUpper,N as trim,X as type,E as values,le as waitAll,b as when};
