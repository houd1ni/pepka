const e=function(){},r=r=>r===e,t=e=>{let t=0;for(let n in e)!r(e[n])&&t++;return t},n=(e,n)=>{const c=t(e),l=n.length,a={};let o=0,s=0;for(;o<c;o++)a[o]=r(e[o])&&s<l?n[s++]:e[o];for(;s<l;s++)a[c+s]=n[s];return a},c=(e,r,l)=>{const a=e.length-t(r)-t(l);return a<1?e(...(e=>{const r=t(e),n=Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n})(n(r,l)),...l.slice(-a)):(...t)=>c(e,n(r,l),t)},l=e=>(...r)=>e.length>t(r)?c(e,{},r):e(...r),a=e=>typeof e,o=e=>null===e,s=e=>"number"==a(e),u=l((e,r)=>{if("object"==a(e)&&"object"==a(r)){if(o(e)||o(r))return e===r;for(let t of[e,r])for(let n in t)if(!u(e[n],r[n]))return!1}return e===r}),i=l((e,r,t,n)=>e(n)?r(n):t(n)),f=l((e,r,t)=>i(e,r,x,t)),b=(...e)=>r=>{for(let t=k(e)-1;t>-1;t--)r=e[t](r);return r},j=l((e,r)=>r[e]),y=l((e,r)=>r.includes(e)),h=l((e,r,t)=>t.slice(e,s(r)?r:1/0)),d=e=>e.toLowerCase(),g=e=>e.toUpperCase(),w=j(0),O=h(1,null),A=l((e,r)=>e+r),p=l((e,r)=>r-e),m=e=>l((r,t)=>e(t,r)),v=e=>o(e)||(e=>void 0===e)(e),k=e=>e.length,N=e=>()=>e,x=e=>e,C=e=>e.trim(),P=e=>e[k(e)-1],E=e=>!e,I=e=>r=>E(e(r)),L=e=>Object.keys(e),S=e=>Object.values(e),U=e=>Object.entries(e),q=e=>r=>(e(r),r),z=l((e,r)=>e>r),B=l((e,r)=>e<r),D=l((e,r)=>r>=e),F=l((e,r)=>r<=e),G=l((e,r)=>r.findIndex(e)),H=(e,r="log")=>q(t=>console[r](e,t)),J=l((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)}),K=l((e,r,t)=>({...t,[e]:r})),M=l((e,r)=>r[e]),Q=l((e,r,t)=>i(k,b(i(v,N(e),t=>Q(e,h(1,null,r),t)),m(M)(t),w),N(t))(r)),R=Q(void 0),T=e=>{switch(a(e)){case"object":switch(re(e)){case"Null":return e;case"Array":return $(T,e);case"Object":const r={};for(let t in e)r[t]=T(e[t]);return r}default:return e}},V=l((e,r,t)=>t.reduce(e,T(r))),W=l((e,r)=>V((e,t)=>e[t]=r[t],{},e)),X=l((e,r)=>ce((r,t)=>!y(t,e),r)),Y=e=>V((e,r)=>K(...r,e),{},e),Z=l((e,r)=>r.join(e)),$=l((e,r)=>r.map(e)),_=l((e,r)=>r.forEach(e)),ee=l((e,r,t)=>r(t)&&e(t)),re=e=>{const r=a(e);return"object"==r?(e=>Array.isArray(e))(e)?"Array":o(e)?"Null":"Object":g(r[0])+r.slice(1)},te=e=>{switch(re(e)){case"String":return""==e;case"Array":return 0==k(e);case"Null":return!1;case"Object":return 0==k(Object.keys(e));default:return!1}},ne=l((e,r,t)=>t.replace(e,r)),ce=l((e,r)=>i(b(u("Array"),re),r=>r.filter(e),b(Y,ce(([r,t])=>e(t,r)),U))(r)),le=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},ae=l((e,r)=>Object.assign({},e,r)),oe=l((e,r)=>{for(let n in r)switch(re(r[n])){case"Array":case"Object":if(t=e[n],"object"==a(t)&&!o(t)){oe(e[n],r[n]);break}default:e[n]=r[n]}var t;return e}),se=l((e,r)=>b(Y,ce(I(v)),$(([r,t])=>o(e[r])?null:[e[r]||r,t]),U)(r)),ue=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return l((r,t)=>e(r,t,0))})(),ie=e=>Promise.all(e),fe=l((e,r)=>Promise.all(r.map(e))),be=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})(),je=x,ye=x,he=x;export{e as __,A as add,N as always,K as assoc,ee as both,T as clone,I as complement,b as compose,be as composeAsync,J as cond,l as curry,he as echo,u as equals,H as explore,ce as filter,G as findIndex,m as flip,_ as forEach,fe as forEachAsync,ue as forEachSerial,Y as fromPairs,z as gt,D as gte,w as head,x as identity,i as ifElse,y as includes,te as isEmpty,v as isNil,Z as join,L as keys,P as last,k as length,B as lt,F as lte,$ as map,se as mapKeys,le as memoize,oe as mergeDeep,ae as mergeShallow,je as mirror,E as not,j as nth,X as omit,R as path,Q as pathOr,W as pick,M as prop,V as reduce,ye as reflect,ne as replace,h as slice,p as subtract,O as tail,q as tap,d as toLower,U as toPairs,g as toUpper,C as trim,re as type,S as values,ie as waitAll,f as when};
