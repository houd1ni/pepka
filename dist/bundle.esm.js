const e=Symbol("Placeholder"),r=r=>{let t=0;for(const n of r)n!==e&&t++;return t},t=(r,t)=>{const n=r.length,s=r.slice(),c=t.length;let o=c,u=0;for(;o&&u<n;u++)s[u]===e&&(s[u]=t[c-o],o--);for(u=n;o;u++,o--)s[u]=t[c-o];return s},n=(e,s,c)=>{const o=e.length-s.length-r(c);if(o<1)return e(...t(s,c));{const r=(...r)=>n(e,t(s,c),r);return r.$args_left=o,r}},s=e=>(...t)=>e.length>r(t)?n(e,[],t):e(...t),c=r=>function(t){return t===e?r:r(t)};function o(r){return function(t,n){const s=t===e,o=arguments.length;if(1===o&&s)throw new Error("Senseless placeholder usage.");return arguments.length>1?s?c((e=>r(e,n))):r(t,n):e=>r(t,e)}}function u(e){return s(e)}const a=void 0,l=1/0,i=e=>typeof e,f=e=>null===e,h=e=>"number"==i(e),b=e=>Array.isArray(e),g=e=>"function"===i(e),p={u:"U",b:"B",n:"N",s:"S",f:"F"},y=e=>e.toLowerCase(),d=e=>e.toUpperCase(),j=e=>{const r=i(e);return"object"===r?f(e)?"Null":e.constructor.name:p[r[0]]+r.slice(1)},m=o(((e,r)=>(r.push(e),r))),w=u(((e,r,t)=>(t[e]=r,t))),O=u(((e,r,t)=>t.reduce(e,r))),A=u(((e,r,t)=>{for(let n in t)switch(j(t[n])){case"Array":if(e>1&&"Array"===j(r[n]))switch(e){case 2:const s=r[n],c=t[n];for(const r in c)s[r]?A(e,s[r],c[r]):s[r]=c[r];break;case 3:r[n].push(...t[n])}else r[n]=t[n];break;case"Object":if("Object"===j(r[n])){A(e,r[n],t[n]);break}default:r[n]=t[n]}return r})),S=A(1),k=A(2),v=A(3),N=o(((e,r)=>{let t,n,s,c;for(t in e)n=e[t],[s,c]=g(n)?n(r):[n,r[t]],r[s]=c,t!==s&&delete r[t];return r})),x=o(((e,r)=>{const t=b(r);for(let n in r)e(r[n],n)||(t?r.splice(n,1):delete r[n]);return r})),C=o(((e,r)=>r.indexOf(e))),P=e=>(...r)=>O(((e,r)=>e?e(r):e),e,r),$=o(((e,r)=>{const t=j(e);if(t===j(r)&&("Object"===t||"Array"==t)){if(f(e)||f(r))return e===r;if(e===r)return!0;for(const t of[e,r])for(const n in t)if(!(t===r&&n in e||t===e&&n in r&&$(e[n],r[n])))return!1;return!0}return e===r})),B=s(((e,r,t,n)=>e(n)?r(n):t(n))),E=u(((e,r,t)=>B(e,r,Q,t))),U=(...r)=>(t=Symbol())=>{for(let n=K(r)-1;n>-1;n--)t=t===e?r[n]():r[n](t);return t},_=o(((e,r)=>e.bind(r))),F=o(((e,r)=>r[e])),I=o(((e,r)=>{if((e=>"string"===i(e))(r))return r.includes(e);for(const t of r)if($(t,e))return!0;return!1})),L=u(((e,r,t)=>t.slice(e,h(r)?r:l))),q=F(0),z=L(1,l),D=o(((e,r)=>e+r)),G=o(((e,r)=>r-e)),H=e=>s(((r,t)=>e(t,r))),J=e=>f(e)||(e=>e===a)(e),K=e=>e.length,M=e=>()=>e,Q=e=>e,R=e=>e.trim(),T=e=>e[K(e)-1],V=e=>!e,W=e=>(...r)=>{const t=e(...r);return g(t)&&t.$args_left?W(t):V(t)},X=e=>Object.keys(e),Y=e=>Object.values(e),Z=e=>Object.entries(e),ee=o(((e,r)=>e.test(r))),re=o(((e,r)=>(e(r),r))),te=o(((e,r)=>[...r,e])),ne=o(((e,r)=>r.split(e))),se=M(!0),ce=M(!1),oe=e=>{if("Object"===j(e)){let r=0;for(let t in e)r++;return r}return K(e)},ue=o(((e,r)=>ie(D(e),r-e))),ae=e=>O(((e,r)=>I(r,e)?e:m(r,e)),[],e),le=o(((e,r)=>e.filter(H(I)(r)))),ie=o(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),fe=e=>{let r,t=!1;return(...n)=>t?r:(t=!0,r=e(...n))},he=e=>U((r=>ze(((t,n,s)=>m(e[r-s],t)),[],e)),D(-1),K)(e),be=o(((e,r)=>e>r)),ge=o(((e,r)=>e<r)),pe=o(((e,r)=>r>=e)),ye=o(((e,r)=>r<=e)),de=o(((e,r)=>r.sort(e))),je=o(((e,r)=>r.find(e))),me=o(((e,r)=>r.findIndex(e))),we=o(((e,r)=>me($(e),r))),Oe=(e,r="log")=>re((t=>console[r](e,t))),Ae=o(((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)})),Se=u(((e,r,t)=>({...t,[e]:r}))),ke=u(((e,r,t)=>U((n=>{return Se(n,K(e)<2?r:ke(L(1,l,e),r,(s=t[n],f(s)||"object"!==i(s)?{}:t[n])),t);var s}),q)(e))),ve=o(((e,r)=>r.every(e))),Ne=o(((e,r)=>r.some(e))),xe=o(((e,r)=>e.every((e=>e(r))))),Ce=o(((e,r)=>e.some((e=>e(r))))),Pe=o(((e,r)=>r[e])),$e=u(((e,r,t)=>$(t[e],r))),Be=u(((e,r,t)=>$(r[e],t[e]))),Ee=u(((e,r,t)=>B(K,(()=>J(t)?e:U(B(J,M(e),(t=>Ee(e,L(1,l,r),t))),H(Pe)(t),q)(r)),M(t),r))),Ue=Ee(a),_e=u(((e,r,t)=>$(Ue(e,t),r))),Fe=u(((e,r,t)=>$(Ue(e,r),Ue(e,t)))),Ie=/^(.*?)(8|16|32|64)(Clamped)?Array$/,Le=(e,r=!1)=>{const t=j(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:Qe(Le,e);case"Object":if(r)return{...e};const n={};for(let r in e)n[r]=Le(e[r]);return n;default:return Ie.test(t)?e.constructor.from(e):e}},qe=e=>Le(e,!0),ze=u(((e,r,t)=>O(e,Le(r),t))),De=o(((e,r)=>Ye(e,r))),Ge=o(((e,r)=>{const t={};for(const n of e)n in r&&(t[n]=r[n]);return t})),He=o(((e,r)=>Ye(((r,t)=>!I(t,e)),r))),Je=e=>ze(((e,r)=>Se(...r,e)),{},e),Ke=o(((e,r)=>e.concat(r))),Me=o(((e,r)=>r.join(e))),Qe=o(((e,r)=>r.map(e))),Re=o(((e,r)=>r.forEach(e))),Te=u(((e,r,t)=>r(t)&&e(t))),Ve=e=>{switch(j(e)){case"String":case"Array":return 0==K(e);case"Object":for(const r in e)return!1;return!0;default:return null}},We=e=>{switch(j(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return a}},Xe=u(((e,r,t)=>t.replace(e,r))),Ye=o(((e,r)=>b(r)?r.filter(e):U(Je,Ye((([r,t])=>e(t,r))),Z)(r))),Ze=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},er=o(((e,r)=>Object.assign({},e,r))),rr=o(((e,r)=>S(Le(e),Le(r)))),tr=o(((e,r)=>k(Le(e),Le(r)))),nr=o(((e,r)=>v(Le(e),Le(r)))),sr=u(((e,r,t)=>Se(e,r(t[e]),t))),cr=o(((e,r)=>N(e,Object.assign({},r)))),or=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return o(((r,t)=>e(r,t,0)))})(),ur=e=>Promise.all(e),ar=o((async(e,r)=>(await e(r),r))),lr=o(((e,r)=>Promise.all(r.map(e)))),ir=(()=>{const e=async(r,t,n)=>~n?await e(r,await r[n](t),--n):t;return(...r)=>t=>e(r,t,r.length-1)})(),fr=Q,hr=Q,br=Q,gr=e=>{const r=[],t=[],n=e.length;let s,c,o=0,u=0,a=!1;for(o=0;o<n;o++)switch(s=e[o],s){case"{":a=!0,u=o;break;case"}":a=!1,r.push(""),t.push(e.slice(u+1,o));break;default:a||(c=r.length-1,c<0&&(r.push(""),c++),r[c]+=s)}return e=>{const n=[],s=r.length-1;for(const c in r)o=+c,n.push(r[o]),o!==s&&n.push(Ue(t[o].split("."),e));return n.join("")}};export{ce as F,se as T,e as __,D as add,ve as all,xe as allPass,M as always,Ne as any,Ce as anyPass,te as append,Se as assoc,ke as assocPath,_ as bind,Te as both,Le as clone,qe as cloneShallow,W as complement,U as compose,ir as composeAsync,Ke as concat,Ae as cond,s as curry,o as curry2,u as curry3,br as echo,We as empty,$ as equals,Oe as explore,Ye as filter,je as find,me as findIndex,H as flip,Re as forEach,lr as forEachAsync,or as forEachSerial,Je as fromPairs,ie as genBy,gr as getTmpl,be as gt,pe as gte,q as head,Q as identity,B as ifElse,I as includes,we as indexOf,le as intersection,Ve as isEmpty,J as isNil,Me as join,X as keys,T as last,K as length,ge as lt,ye as lte,Qe as map,cr as mapKeys,Ze as memoize,rr as mergeDeep,nr as mergeDeepAdd,tr as mergeDeepX,er as mergeShallow,fr as mirror,V as not,F as nth,He as omit,fe as once,sr as overProp,Ue as path,_e as pathEq,Ee as pathOr,Fe as pathsEq,Ge as pick,De as pickBy,Pe as prop,$e as propEq,Be as propsEq,m as qappend,w as qassoc,x as qfilter,C as qindexOf,N as qmapKeys,S as qmergeDeep,v as qmergeDeepAdd,k as qmergeDeepX,O as qreduce,ue as range,ze as reduce,hr as reflect,Xe as replace,he as reverse,oe as sizeof,L as slice,de as sort,ne as split,G as subtract,z as tail,re as tap,ee as test,y as toLower,Z as toPairs,d as toUpper,R as trim,j as type,P as uncurry,ae as uniq,Y as values,ur as waitAll,ar as waitTap,E as when};
