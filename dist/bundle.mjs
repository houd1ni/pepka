const e=Symbol("Placeholder"),r=r=>{let t=0;for(const n of r)n!==e&&t++;return t},t=(r,t)=>{const n=r.length,s=r.slice(),c=t.length;let o=c,i=0;for(;o&&i<n;i++)s[i]===e&&(s[i]=t[c-o],o--);for(i=n;o;i++,o--)s[i]=t[c-o];return s},n=(e,s,c)=>{const o=e.length-s.length-r(c);if(o<1)return e(...t(s,c));{const r=(...r)=>n(e,t(s,c),r);return r.$args_left=o,r}},s=e=>(...t)=>e.length>r(t)?n(e,[],t):e(...t);function c(r){return function(t,n){const s=t===e,c=arguments.length;if(1===c&&s)throw new Error("Senseless placeholder usage.");return c>1?s?(r=>function(t){return t===e?r:r(t)})((e=>r(e,n))):r(t,n):e=>r(t,e)}}function o(e){return s(e)}const i=void 0,u=1/0,l=e=>typeof e,a=e=>null===e,f=e=>"number"==l(e),h=e=>Array.isArray(e),b=e=>"function"===l(e),g=e=>!a(e)&&"object"===l(e),p={u:"U",b:"B",n:"N",s:"S",f:"F"},j=Symbol(),y=e=>e.toLowerCase(),d=e=>e.toUpperCase(),m=e=>{const r=l(e);return"object"===r?a(e)?"Null":e.constructor.name:p[r[0]]+r.slice(1)},O=c(((e,r)=>m(r)===e)),w=e=>e.length,A=e=>a(e)||(e=>e===i)(e),S=c(((e,r)=>e===r)),k=c(((e,r)=>{const t=m(e);if(S(t,m(r))&&(S(t,"Object")||S(t,"Array"))){if(a(e)||a(r))return S(e,r);if(S(e,r))return!0;for(const t of[e,r])for(const n in t)if(!(S(t,r)&&n in e||S(t,e)&&n in r&&k(e[n],r[n])))return!1;return!0}return S(e,r)})),v=c(((e,r)=>{if((e=>"string"===l(e))(r))return r.includes(e);for(const t of r)if(k(t,e))return!0;return!1})),N=e=>c(((r,t)=>{const n=w(r);if(n>w(t))return!1;for(let s=0;s<n;s++)if(!e(t[s],r[s]))return!1;return!0})),C=c(((e,r)=>(r.push(e),r))),E=o(((e,r,t)=>(t[e]=r,t))),P=o(((e,r,t)=>t.reduce(e,r))),$=o(((e,r,t)=>{for(let n in t)switch(m(t[n])){case"Array":if(e>1&&"Array"===m(r[n]))switch(e){case 2:const s=r[n],c=t[n];for(const r in c)s[r]?$(e,s[r],c[r]):s[r]=c[r];break;case 3:r[n].push(...t[n])}else r[n]=t[n];break;case"Object":if("Object"===m(r[n])){$(e,r[n],t[n]);break}default:r[n]=t[n]}return r})),x=$(1),z=$(2),B=$(3),U=c(((e,r)=>Object.assign(e,r))),_=c(((e,r)=>{let t,n,s,c;for(t in e)t in r&&(n=e[t],[s,c]=b(n)?n(r[t],t,r):[n,r[t]],r[A(s)?t:s]=c,t!==s&&delete r[t]);return r})),F=c(((e,r)=>{for(let t in r)r[t]=e(r[t],+t,r);return r})),I=c(((e,r)=>F(e,r))),L=c(((e,r)=>{const t=h(r);let n,s;t&&(n=0,s=[]);for(let n in r)e(r[n],n)||(t?s.push(+n):delete r[n]);if(t)for(const e of s)r.splice(e-n++,1);return r})),q=e=>{if(h(e))e.splice(0);else for(const r in e)delete e[r];return e},D=e=>{let r;for(const t in e)r=e[t],g(r)&&D(r);return Object.freeze(e)},G=e=>Object.freeze(e),H=c(((e,r)=>r.unshift(e))),J=o(((e,r,t)=>{const n=e[0];return E(n,e.length<2?r:J(e.slice(1),r,g(t[n])?t[n]:{}),t)})),K=e=>e.reverse(),M=c(((e,r)=>L(((r,t)=>!v(t,e)),r))),Q=N(S),R=e=>(...r)=>P(((e,r)=>e?e(r):e),e,r),T=e=>(...r)=>r[e],V=c(((e,r)=>e==r)),W=s(((e,r,t,n)=>e(n)?r(n):t(n))),X=o(((e,r,t)=>W(e,r,de,t))),Y=(...r)=>(...t)=>{let n,s=!0;for(let c=w(r)-1;c>-1;c--)s?(s=!1,n=r[c](...t)):n=n===e?r[c]():r[c](n);return n},Z=c(((e,r)=>e.bind(r))),ee=c(((e,r)=>r[e])),re=o(((e,r,t)=>t.slice(e,f(r)?r:u))),te=e=>c(((r,t)=>e(t,r))),ne=ee(0),se=re(1,u),ce=c(((e,r)=>e+r)),oe=c(((e,r)=>r-e)),ie=c(((e,r)=>e*r)),ue=c(((e,r)=>e<r)),le=c(((e,r)=>e>r)),ae=c(((e,r)=>e<=r)),fe=c(((e,r)=>e>=r)),he=c(((e,r)=>r.sort(e))),be=c(((e,r)=>r.find(e))),ge=c(((e,r)=>r.findIndex(e))),pe=c(((e,r)=>ge(k(e),r))),je=c(((e,r)=>e/r)),ye=e=>()=>e,de=e=>e,me=e=>e.trim(),Oe=e=>e[w(e)-1],we=N(((e,r)=>k(e,r))),Ae=e=>!e,Se=e=>Object.keys(e),ke=e=>Object.values(e),ve=e=>Object.entries(e),Ne=c(((e,r)=>e.test(r))),Ce=c(((e,r)=>(e(r),r))),Ee=c(((e,r)=>[...r,e])),Pe=c(((e,r)=>[...r,e])),$e=e=>e.flat(u),xe=e=>e.flat(),ze=c(((e,r)=>r.flat(e))),Be=c(((e,r)=>r.split(e))),Ue=ye(!0),_e=ye(!1),Fe=c(((e,r)=>r(...e))),Ie=()=>{},Le=s(((e,r,t)=>t[r](...e))),qe=e=>(...r)=>{const t=e(...r),n=b(t);return!n||n&&t.$args_left<=0?Ae(t):qe(t)},De=e=>{if("Object"===m(e)){let r=0;for(let t in e)r++;return r}return w(e)},Ge=c(((e,r)=>Ke(ce(e),r-e))),He=e=>P(((e,r)=>be(k(r),e)?e:C(r,e)),[],e),Je=c(((e,r)=>e.filter(te(v)(r)))),Ke=c(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),Me=e=>{let r,t=!1;return(...n)=>t?r:(t=!0,r=e(...n))},Qe=e=>Y((r=>gr(((t,n,s)=>C(e[r-s],t)),[],e)),ce(-1),w)(e),Re=(e,r="log")=>Ce((t=>console[r](e,t))),Te=c(((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)})),Ve=o(((e,r,t)=>({...t,[e]:r}))),We=o(((e,r,t)=>Y((n=>Ve(n,w(e)<2?r:We(re(1,u,e),r,g(t[n])?t[n]:{}),t)),ne)(e))),Xe=c(((e,r)=>r.every(e))),Ye=c(((e,r)=>r.some(e))),Ze=c(((e,r)=>e.every((e=>e(r))))),er=c(((e,r)=>e.some((e=>e(r))))),rr=c(((e,r)=>r[e])),tr=o(((e,r,t)=>k(t[e],r))),nr=o(((e,r,t)=>k(r[e],t[e]))),sr=o(((e,r,t)=>w(r)?A(t)?e:Y((n=>n in t?sr(e,re(1,u,r),t[n]):e),ne)(r):t)),cr=sr(i),or=o(((e,r,t)=>k(cr(e,t),r))),ir=o(((e,r,t)=>k(cr(e,r),cr(e,t)))),ur=Y(W(k(j),_e,Ue),sr(j)),lr=/^(.*?)(8|16|32|64)(Clamped)?Array$/,ar=(e,r=!1)=>{const t=m(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:Or(Y(ar,T(0)),e);case"Object":if(r)return{...e};const n={};for(let r in e)n[r]=ar(e[r]);return n;default:return lr.test(t)?e.constructor.from(e):e}},fr=e=>ar(e,!0),hr=e=>D(ar(e)),br=e=>G(ar(e)),gr=o(((e,r,t)=>P(e,ar(r),t))),pr=c(((e,r)=>Er(e,r))),jr=c(((e,r)=>{const t={};for(const n of e)n in r&&(t[n]=r[n]);return t})),yr=c(((e,r)=>Er(((r,t)=>!v(t,e)),r))),dr=e=>Object.fromEntries(e),mr=c(((e,r)=>r.concat(e))),Or=c(((e,r)=>r.map(e))),wr=c(((e,r)=>I(e,fr(r)))),Ar=c(((e,r)=>r.join(e))),Sr=c(((e,r)=>r.forEach(e))),kr=o(((e,r,t)=>r(t)&&e(t))),vr=e=>{switch(m(e)){case"String":case"Array":return 0==w(e);case"Object":for(const r in e)return!1;return!0;default:return null}},Nr=e=>{switch(m(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return i}},Cr=o(((e,r,t)=>t.replace(e,r))),Er=c(((e,r)=>h(r)?r.filter(e):L(e,{...r}))),Pr=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},$r=c(((e,r)=>Object.assign({},e,r))),xr=c(((e,r)=>x(ar(e),ar(r)))),zr=c(((e,r)=>z(ar(e),ar(r)))),Br=c(((e,r)=>B(ar(e),ar(r)))),Ur=o(((e,r,t)=>Ve(e,r(t[e]),t))),_r=c(((e,r)=>_(e,Object.assign({},r)))),Fr=c(((e,r)=>Or(((e,t)=>[e,r[t]]),e))),Ir=c(((e,r)=>gr(((e,t,n)=>Ve(t,r[n],e)),{},e))),Lr=o(((e,r,t)=>Or(((r,n)=>e(r,t[n])),r))),qr=de,Dr=de,Gr=de,Hr=qe,Jr=Ee,Kr=Ye,Mr=e=>{const r=[],t=[],n=e.length;let s,c,o,i=0,u=0,l=!1,a=ne(e),f=!1;for(i=0;i<n;i++)switch(s=e[i],s){case"{":if(!a){l=!0,u=i;break}case"}":if(!a){l=!1,r.push(""),t.push(e.slice(u+1,i));break}default:o=e[i+1],f="\\"===s,l||f&&("{"===o||"}"===o)||(c=r.length-1,c<0&&(r.push(""),c++),r[c]+=s),a=f}return e=>{const n=[],s=r.length-1;for(const c in r)i=+c,n.push(r[i]),i!==s&&n.push(cr(t[i].split("."),e));return n.join("")}},Qr=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c(((r,t)=>e(r,t,0)))})(),Rr=e=>Promise.all(e),Tr=c((async(e,r)=>(await e(r),r))),Vr=c(((e,r)=>Promise.all(r.map(e)))),Wr=(()=>{const e=async(r,t,n)=>~n?await e(r,[await r[n](...t)],--n):ne(t);return(...r)=>(...t)=>e(r,t,r.length-1)})();export{_e as F,Ue as T,e as __,ce as add,Xe as all,Ze as allPass,ye as always,Ye as any,er as anyPass,Ee as append,Ve as assoc,We as assocPath,Z as bind,kr as both,Le as callFrom,Fe as callWith,ar as clone,fr as cloneShallow,qe as complement,Y as compose,Wr as composeAsync,mr as concat,Te as cond,s as curry,c as curry2,o as curry3,je as divide,Gr as echo,Nr as empty,S as eq,k as equals,Re as explore,Er as filter,be as find,ge as findIndex,$e as flat,xe as flatShallow,ze as flatTo,te as flip,Sr as forEach,Vr as forEachAsync,Qr as forEachSerial,hr as freeze,br as freezeShallow,dr as fromPairs,Ke as genBy,Mr as getTmpl,ue as gt,ae as gte,ne as head,de as identity,W as ifElse,v as includes,pe as indexOf,Je as intersection,vr as isEmpty,A as isNil,Ar as join,Se as keys,Oe as last,w as length,le as lt,fe as lte,Or as map,_r as mapKeys,wr as mapObj,Pr as memoize,xr as mergeDeep,Br as mergeDeepAdd,zr as mergeDeepX,$r as mergeShallow,qr as mirror,ie as multiply,Ie as noop,Ae as not,Hr as notf,ee as nth,yr as omit,Me as once,Ur as overProp,cr as path,or as pathEq,ur as pathExists,sr as pathOr,ir as pathsEq,jr as pick,pr as pickBy,Pe as prepend,rr as prop,tr as propEq,nr as propsEq,Jr as push,C as qappend,E as qassoc,J as qassocPath,q as qempty,L as qfilter,D as qfreeze,G as qfreezeShallow,F as qmap,_ as qmapKeys,I as qmapObj,x as qmergeDeep,B as qmergeDeepAdd,z as qmergeDeepX,U as qmergeShallow,M as qomit,H as qprepend,P as qreduce,K as qreverse,Q as qstartsWith,N as qstartsWithWith,Ge as range,gr as reduce,Dr as reflect,Cr as replace,Qe as reverse,De as sizeof,re as slice,Kr as some,he as sort,Be as split,we as startsWith,oe as subtract,j as symbol,se as tail,T as take,Ce as tap,Ne as test,y as toLower,ve as toPairs,d as toUpper,me as trim,m as type,O as typeIs,R as uncurry,He as uniq,ke as values,Rr as waitAll,Tr as waitTap,V as weakEq,X as when,Fr as zip,Ir as zipObj,Lr as zipWith};
