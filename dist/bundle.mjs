const e=Symbol("Placeholder"),r=r=>{let t=0;for(const n of r)n!==e&&t++;return t},t=(r,t)=>{const n=r.length,s=r.slice(),c=t.length;let o=c,l=0;for(;o&&l<n;l++)s[l]===e&&(s[l]=t[c-o],o--);for(l=n;o;l++,o--)s[l]=t[c-o];return s},n=(e,s,c)=>{const o=e.length-s.length-r(c);if(o<1)return e(...t(s,c));{const r=(...r)=>n(e,t(s,c),r);return r.$args_left=o,r}},s=e=>(...t)=>e.length>r(t)?n(e,[],t):e(...t);function c(r){return function(t,n){const s=t===e;if(1===arguments.length&&s)throw new Error("Senseless placeholder usage.");return arguments.length>1?s?(r=>function(t){return t===e?r:r(t)})((e=>r(e,n))):r(t,n):e=>r(t,e)}}function o(e){return s(e)}const l=void 0,i=1/0,u=e=>typeof e,a=e=>null===e,f=e=>"number"==u(e),h=e=>Array.isArray(e),b=e=>"function"===u(e),g=e=>!a(e)&&"object"===u(e),p={u:"U",b:"B",n:"N",s:"S",f:"F"},j=e=>e.toLowerCase(),y=e=>e.toUpperCase(),d=e=>{const r=u(e);return"object"===r?a(e)?"Null":e.constructor.name:p[r[0]]+r.slice(1)},m=c(((e,r)=>d(r)===e)),O=e=>(...r)=>r[e],w=c(((e,r)=>e===r)),A=c(((e,r)=>e==r)),S=c(((e,r)=>{const t=d(e);if(w(t,d(r))&&(w(t,"Object")||w(t,"Array"))){if(a(e)||a(r))return w(e,r);if(w(e,r))return!0;for(const t of[e,r])for(const n in t)if(!(w(t,r)&&n in e||w(t,e)&&n in r&&S(e[n],r[n])))return!1;return!0}return w(e,r)})),k=s(((e,r,t,n)=>e(n)?r(n):t(n))),v=o(((e,r,t)=>k(e,r,V,t))),N=(...r)=>(...t)=>{let n,s=!0;for(let c=R(r)-1;c>-1;c--)s?(s=!1,n=r[c](...t)):n=n===e?r[c]():r[c](n);return n},C=c(((e,r)=>e.bind(r))),E=c(((e,r)=>r[e])),P=c(((e,r)=>{if((e=>"string"===u(e))(r))return r.includes(e);for(const t of r)if(S(t,e))return!0;return!1})),$=o(((e,r,t)=>t.slice(e,f(r)?r:i))),x=e=>c(((r,t)=>e(t,r))),z=E(0),B=$(1,i),U=c(((e,r)=>e+r)),_=c(((e,r)=>r-e)),D=c(((e,r)=>e*r)),F=c(((e,r)=>e>r)),I=c(((e,r)=>e<r)),L=c(((e,r)=>r>=e)),q=c(((e,r)=>r<=e)),G=c(((e,r)=>r.sort(e))),H=c(((e,r)=>r.find(e))),J=c(((e,r)=>r.findIndex(e))),K=c(((e,r)=>J(S(e),r))),M=c(((e,r)=>e/r)),Q=e=>a(e)||(e=>e===l)(e),R=e=>e.length,T=e=>()=>e,V=e=>e,W=e=>e.trim(),X=e=>e[R(e)-1],Y=e=>!e,Z=e=>Object.keys(e),ee=e=>Object.values(e),re=e=>Object.entries(e),te=c(((e,r)=>e.test(r))),ne=c(((e,r)=>(e(r),r))),se=c(((e,r)=>[...r,e])),ce=c(((e,r)=>[...r,e])),oe=e=>e.flat(i),le=e=>e.flat(),ie=c(((e,r)=>r.flat(e))),ue=c(((e,r)=>r.split(e))),ae=T(!0),fe=T(!1),he=c(((e,r)=>r(...e))),be=()=>{},ge=s(((e,r,t)=>t[r](...e))),pe=e=>(...r)=>{const t=e(...r),n=b(t);return!n||n&&t.$args_left<=0?Y(t):pe(t)},je=e=>{if("Object"===d(e)){let r=0;for(let t in e)r++;return r}return R(e)},ye=c(((e,r)=>Oe(U(e),r-e))),de=e=>Nr(((e,r)=>P(r,e)?e:kr(r,e)),[],e),me=c(((e,r)=>e.filter(x(P)(r)))),Oe=c(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),we=e=>{let r,t=!1;return(...n)=>t?r:(t=!0,r=e(...n))},Ae=e=>N((r=>Je(((t,n,s)=>kr(e[r-s],t)),[],e)),U(-1),R)(e),Se=(e,r="log")=>ne((t=>console[r](e,t))),ke=c(((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)})),ve=o(((e,r,t)=>({...t,[e]:r}))),Ne=o(((e,r,t)=>N((n=>ve(n,R(e)<2?r:Ne($(1,i,e),r,g(t[n])?t[n]:{}),t)),z)(e))),Ce=c(((e,r)=>r.every(e))),Ee=c(((e,r)=>r.some(e))),Pe=c(((e,r)=>e.every((e=>e(r))))),$e=c(((e,r)=>e.some((e=>e(r))))),xe=c(((e,r)=>r[e])),ze=o(((e,r,t)=>S(t[e],r))),Be=o(((e,r,t)=>S(r[e],t[e]))),Ue=o(((e,r,t)=>k(R,(()=>Q(t)?e:N(k(Q,T(e),(t=>Ue(e,$(1,i,r),t))),x(xe)(t),z)(r)),T(t),r))),_e=Ue(l),De=o(((e,r,t)=>S(_e(e,t),r))),Fe=o(((e,r,t)=>S(_e(e,r),_e(e,t)))),Ie=/^(.*?)(8|16|32|64)(Clamped)?Array$/,Le=(e,r=!1)=>{const t=d(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:We(N(Le,O(0)),e);case"Object":if(r)return{...e};const n={};for(let r in e)n[r]=Le(e[r]);return n;default:return Ie.test(t)?e.constructor.from(e):e}},qe=e=>Le(e,!0),Ge=e=>Dr(Le(e)),He=e=>Fr(Le(e)),Je=o(((e,r,t)=>Nr(e,Le(r),t))),Ke=c(((e,r)=>tr(e,r))),Me=c(((e,r)=>{const t={};for(const n of e)n in r&&(t[n]=r[n]);return t})),Qe=c(((e,r)=>tr(((r,t)=>!P(t,e)),r))),Re=e=>Object.fromEntries(e),Te=c(((e,r)=>r.concat(e))),Ve=c(((e,r)=>r.join(e))),We=c(((e,r)=>r.map(e))),Xe=c(((e,r)=>r.forEach(e))),Ye=o(((e,r,t)=>r(t)&&e(t))),Ze=e=>{switch(d(e)){case"String":case"Array":return 0==R(e);case"Object":for(const r in e)return!1;return!0;default:return null}},er=e=>{switch(d(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return l}},rr=o(((e,r,t)=>t.replace(e,r))),tr=c(((e,r)=>h(r)?r.filter(e):Ur(e,{...r}))),nr=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},sr=c(((e,r)=>Object.assign({},e,r))),cr=c(((e,r)=>Er(Le(e),Le(r)))),or=c(((e,r)=>Pr(Le(e),Le(r)))),lr=c(((e,r)=>$r(Le(e),Le(r)))),ir=o(((e,r,t)=>ve(e,r(t[e]),t))),ur=c(((e,r)=>zr(e,Object.assign({},r)))),ar=c(((e,r)=>We(((e,t)=>[e,r[t]]),e))),fr=c(((e,r)=>Je(((e,t,n)=>ve(t,r[n],e)),{},e))),hr=o(((e,r,t)=>We(((r,n)=>e(r,t[n])),r))),br=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c(((r,t)=>e(r,t,0)))})(),gr=e=>Promise.all(e),pr=c((async(e,r)=>(await e(r),r))),jr=c(((e,r)=>Promise.all(r.map(e)))),yr=(()=>{const e=async(r,t,n)=>~n?await e(r,[await r[n](...t)],--n):z(t);return(...r)=>(...t)=>e(r,t,r.length-1)})(),dr=V,mr=V,Or=V,wr=pe,Ar=se,Sr=Ee,kr=c(((e,r)=>(r.push(e),r))),vr=o(((e,r,t)=>(t[e]=r,t))),Nr=o(((e,r,t)=>t.reduce(e,r))),Cr=o(((e,r,t)=>{for(let n in t)switch(d(t[n])){case"Array":if(e>1&&"Array"===d(r[n]))switch(e){case 2:const s=r[n],c=t[n];for(const r in c)s[r]?Cr(e,s[r],c[r]):s[r]=c[r];break;case 3:r[n].push(...t[n])}else r[n]=t[n];break;case"Object":if("Object"===d(r[n])){Cr(e,r[n],t[n]);break}default:r[n]=t[n]}return r})),Er=Cr(1),Pr=Cr(2),$r=Cr(3),xr=c(((e,r)=>Object.assign(e,r))),zr=c(((e,r)=>{let t,n,s,c;for(t in e)t in r&&(n=e[t],[s,c]=b(n)?n(r[t],t,r):[n,r[t]],r[Q(s)?t:s]=c,t!==s&&delete r[t]);return r})),Br=c(((e,r)=>{for(let t in r)r[t]=e(r[t],+t,r);return r})),Ur=c(((e,r)=>{const t=h(r);let n,s;t&&(n=0,s=[]);for(let n in r)e(r[n],n)||(t?s.push(+n):delete r[n]);if(t)for(const e of s)r.splice(e-n++,1);return r})),_r=e=>{if(h(e))e.splice(0);else for(const r in e)delete e[r];return e},Dr=e=>{let r;for(const t in e)r=e[t],g(r)&&Dr(r);return Object.freeze(e)},Fr=e=>Object.freeze(e),Ir=c(((e,r)=>r.unshift(e))),Lr=o(((e,r,t)=>{const n=e[0];return vr(n,e.length<2?r:Lr(e.slice(1),r,g(t[n])?t[n]:{}),t)})),qr=e=>e.reverse(),Gr=c(((e,r)=>Ur(((r,t)=>!P(t,e)),r))),Hr=e=>(...r)=>Nr(((e,r)=>e?e(r):e),e,r),Jr=e=>{const r=[],t=[],n=e.length;let s,c,o,l=0,i=0,u=!1,a=z(e),f=!1;for(l=0;l<n;l++)switch(s=e[l],s){case"{":if(!a){u=!0,i=l;break}case"}":if(!a){u=!1,r.push(""),t.push(e.slice(i+1,l));break}default:o=e[l+1],f="\\"===s,u||f&&("{"===o||"}"===o)||(c=r.length-1,c<0&&(r.push(""),c++),r[c]+=s),a=f}return e=>{const n=[],s=r.length-1;for(const c in r)l=+c,n.push(r[l]),l!==s&&n.push(_e(t[l].split("."),e));return n.join("")}};export{fe as F,ae as T,e as __,U as add,Ce as all,Pe as allPass,T as always,Ee as any,$e as anyPass,se as append,ve as assoc,Ne as assocPath,C as bind,Ye as both,ge as callFrom,he as callWith,Le as clone,qe as cloneShallow,pe as complement,N as compose,yr as composeAsync,Te as concat,ke as cond,s as curry,c as curry2,o as curry3,M as divide,Or as echo,er as empty,w as eq,S as equals,Se as explore,tr as filter,H as find,J as findIndex,oe as flat,le as flatShallow,ie as flatTo,x as flip,Xe as forEach,jr as forEachAsync,br as forEachSerial,Ge as freeze,He as freezeShallow,Re as fromPairs,Oe as genBy,Jr as getTmpl,F as gt,L as gte,z as head,V as identity,k as ifElse,P as includes,K as indexOf,me as intersection,Ze as isEmpty,Q as isNil,Ve as join,Z as keys,X as last,R as length,I as lt,q as lte,We as map,ur as mapKeys,nr as memoize,cr as mergeDeep,lr as mergeDeepAdd,or as mergeDeepX,sr as mergeShallow,dr as mirror,D as multiply,be as noop,Y as not,wr as notf,E as nth,Qe as omit,we as once,ir as overProp,_e as path,De as pathEq,Ue as pathOr,Fe as pathsEq,Me as pick,Ke as pickBy,ce as prepend,xe as prop,ze as propEq,Be as propsEq,Ar as push,kr as qappend,vr as qassoc,Lr as qassocPath,_r as qempty,Ur as qfilter,Dr as qfreeze,Fr as qfreezeShallow,Br as qmap,zr as qmapKeys,Er as qmergeDeep,$r as qmergeDeepAdd,Pr as qmergeDeepX,xr as qmergeShallow,Gr as qomit,Ir as qprepend,Nr as qreduce,qr as qreverse,ye as range,Je as reduce,mr as reflect,rr as replace,Ae as reverse,je as sizeof,$ as slice,Sr as some,G as sort,ue as split,_ as subtract,B as tail,O as take,ne as tap,te as test,j as toLower,re as toPairs,y as toUpper,W as trim,d as type,m as typeIs,Hr as uncurry,de as uniq,ee as values,gr as waitAll,pr as waitTap,A as weakEq,v as when,ar as zip,fr as zipObj,hr as zipWith};
