const e=Symbol("Placeholder"),r=r=>{let t=0;for(const n of r)n!==e&&t++;return t},t=(r,t)=>{const n=r.length,s=r.slice(),c=t.length;let o=c,l=0;for(;o&&l<n;l++)s[l]===e&&(s[l]=t[c-o],o--);for(l=n;o;l++,o--)s[l]=t[c-o];return s},n=(e,s,c)=>{const o=e.length-s.length-r(c);if(o<1)return e(...t(s,c));{const r=(...r)=>n(e,t(s,c),r);return r.$args_left=o,r}},s=e=>(...t)=>e.length>r(t)?n(e,[],t):e(...t),c=r=>function(t){return t===e?r:r(t)};function o(r){return function(t,n){const s=t===e,o=arguments.length;if(1===o&&s)throw new Error("Senseless placeholder usage.");return arguments.length>1?s?c((e=>r(e,n))):r(t,n):e=>r(t,e)}}function l(e){return s(e)}const i=void 0,u=1/0,a=e=>typeof e,f=e=>null===e,h=e=>"number"==a(e),b=e=>Array.isArray(e),g=e=>"function"===a(e),p=e=>!f(e)&&"object"===a(e),j={u:"U",b:"B",n:"N",s:"S",f:"F"},y=e=>e.toLowerCase(),d=e=>e.toUpperCase(),m=e=>{const r=a(e);return"object"===r?f(e)?"Null":e.constructor.name:j[r[0]]+r.slice(1)},O=o(((e,r)=>m(r)===e)),w=e=>(...r)=>r[e],A=o(((e,r)=>e===r)),S=o(((e,r)=>e==r)),k=o(((e,r)=>{const t=m(e);if(A(t,m(r))&&(A(t,"Object")||A(t,"Array"))){if(f(e)||f(r))return A(e,r);if(A(e,r))return!0;for(const t of[e,r])for(const n in t)if(!(A(t,r)&&n in e||A(t,e)&&n in r&&k(e[n],r[n])))return!1;return!0}return A(e,r)})),v=s(((e,r,t,n)=>e(n)?r(n):t(n))),N=l(((e,r,t)=>v(e,r,W,t))),C=(...r)=>(...t)=>{let n,s=!0;for(let c=T(r)-1;c>-1;c--)s?(s=!1,n=r[c](...t)):n=n===e?r[c]():r[c](n);return n},E=o(((e,r)=>e.bind(r))),P=o(((e,r)=>r[e])),$=o(((e,r)=>{if((e=>"string"===a(e))(r))return r.includes(e);for(const t of r)if(k(t,e))return!0;return!1})),x=l(((e,r,t)=>t.slice(e,h(r)?r:u))),z=e=>o(((r,t)=>e(t,r))),B=P(0),U=x(1,u),_=o(((e,r)=>e+r)),D=o(((e,r)=>r-e)),F=o(((e,r)=>e*r)),I=o(((e,r)=>e>r)),L=o(((e,r)=>e<r)),q=o(((e,r)=>r>=e)),G=o(((e,r)=>r<=e)),H=o(((e,r)=>r.sort(e))),J=o(((e,r)=>r.find(e))),K=o(((e,r)=>r.findIndex(e))),M=o(((e,r)=>K(k(e),r))),Q=o(((e,r)=>e/r)),R=e=>f(e)||(e=>e===i)(e),T=e=>e.length,V=e=>()=>e,W=e=>e,X=e=>e.trim(),Y=e=>e[T(e)-1],Z=e=>!e,ee=e=>Object.keys(e),re=e=>Object.values(e),te=e=>Object.entries(e),ne=o(((e,r)=>e.test(r))),se=o(((e,r)=>(e(r),r))),ce=o(((e,r)=>[...r,e])),oe=o(((e,r)=>[...r,e])),le=e=>e.flat(u),ie=e=>e.flat(),ue=o(((e,r)=>r.flat(e))),ae=o(((e,r)=>r.split(e))),fe=V(!0),he=V(!1),be=o(((e,r)=>r(...e))),ge=()=>{},pe=s(((e,r,t)=>t[r](...e))),je=e=>(...r)=>{const t=e(...r),n=g(t);return!n||n&&t.$args_left<=0?Z(t):je(t)},ye=e=>{if("Object"===m(e)){let r=0;for(let t in e)r++;return r}return T(e)},de=o(((e,r)=>we(_(e),r-e))),me=e=>Cr(((e,r)=>$(r,e)?e:vr(r,e)),[],e),Oe=o(((e,r)=>e.filter(z($)(r)))),we=o(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),Ae=e=>{let r,t=!1;return(...n)=>t?r:(t=!0,r=e(...n))},Se=e=>C((r=>Ke(((t,n,s)=>vr(e[r-s],t)),[],e)),_(-1),T)(e),ke=(e,r="log")=>se((t=>console[r](e,t))),ve=o(((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)})),Ne=l(((e,r,t)=>({...t,[e]:r}))),Ce=l(((e,r,t)=>C((n=>Ne(n,T(e)<2?r:Ce(x(1,u,e),r,p(t[n])?t[n]:{}),t)),B)(e))),Ee=o(((e,r)=>r.every(e))),Pe=o(((e,r)=>r.some(e))),$e=o(((e,r)=>e.every((e=>e(r))))),xe=o(((e,r)=>e.some((e=>e(r))))),ze=o(((e,r)=>r[e])),Be=l(((e,r,t)=>k(t[e],r))),Ue=l(((e,r,t)=>k(r[e],t[e]))),_e=l(((e,r,t)=>v(T,(()=>R(t)?e:C(v(R,V(e),(t=>_e(e,x(1,u,r),t))),z(ze)(t),B)(r)),V(t),r))),De=_e(i),Fe=l(((e,r,t)=>k(De(e,t),r))),Ie=l(((e,r,t)=>k(De(e,r),De(e,t)))),Le=/^(.*?)(8|16|32|64)(Clamped)?Array$/,qe=(e,r=!1)=>{const t=m(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:Xe(C(qe,w(0)),e);case"Object":if(r)return{...e};const n={};for(let r in e)n[r]=qe(e[r]);return n;default:return Le.test(t)?e.constructor.from(e):e}},Ge=e=>qe(e,!0),He=e=>Fr(qe(e)),Je=e=>Ir(qe(e)),Ke=l(((e,r,t)=>Cr(e,qe(r),t))),Me=o(((e,r)=>nr(e,r))),Qe=o(((e,r)=>{const t={};for(const n of e)n in r&&(t[n]=r[n]);return t})),Re=o(((e,r)=>nr(((r,t)=>!$(t,e)),r))),Te=e=>Object.fromEntries(e),Ve=o(((e,r)=>r.concat(e))),We=o(((e,r)=>r.join(e))),Xe=o(((e,r)=>r.map(e))),Ye=o(((e,r)=>r.forEach(e))),Ze=l(((e,r,t)=>r(t)&&e(t))),er=e=>{switch(m(e)){case"String":case"Array":return 0==T(e);case"Object":for(const r in e)return!1;return!0;default:return null}},rr=e=>{switch(m(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return i}},tr=l(((e,r,t)=>t.replace(e,r))),nr=o(((e,r)=>b(r)?r.filter(e):_r(e,{...r}))),sr=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},cr=o(((e,r)=>Object.assign({},e,r))),or=o(((e,r)=>Pr(qe(e),qe(r)))),lr=o(((e,r)=>$r(qe(e),qe(r)))),ir=o(((e,r)=>xr(qe(e),qe(r)))),ur=l(((e,r,t)=>Ne(e,r(t[e]),t))),ar=o(((e,r)=>Br(e,Object.assign({},r)))),fr=o(((e,r)=>Xe(((e,t)=>[e,r[t]]),e))),hr=o(((e,r)=>Ke(((e,t,n)=>Ne(t,r[n],e)),{},e))),br=l(((e,r,t)=>Xe(((r,n)=>e(r,t[n])),r))),gr=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return o(((r,t)=>e(r,t,0)))})(),pr=e=>Promise.all(e),jr=o((async(e,r)=>(await e(r),r))),yr=o(((e,r)=>Promise.all(r.map(e)))),dr=(()=>{const e=async(r,t,n)=>~n?await e(r,[await r[n](...t)],--n):B(t);return(...r)=>(...t)=>e(r,t,r.length-1)})(),mr=W,Or=W,wr=W,Ar=je,Sr=ce,kr=Pe,vr=o(((e,r)=>(r.push(e),r))),Nr=l(((e,r,t)=>(t[e]=r,t))),Cr=l(((e,r,t)=>t.reduce(e,r))),Er=l(((e,r,t)=>{for(let n in t)switch(m(t[n])){case"Array":if(e>1&&"Array"===m(r[n]))switch(e){case 2:const s=r[n],c=t[n];for(const r in c)s[r]?Er(e,s[r],c[r]):s[r]=c[r];break;case 3:r[n].push(...t[n])}else r[n]=t[n];break;case"Object":if("Object"===m(r[n])){Er(e,r[n],t[n]);break}default:r[n]=t[n]}return r})),Pr=Er(1),$r=Er(2),xr=Er(3),zr=o(((e,r)=>Object.assign(e,r))),Br=o(((e,r)=>{let t,n,s,c;for(t in e)t in r&&(n=e[t],[s,c]=g(n)?n(r[t],t,r):[n,r[t]],r[R(s)?t:s]=c,t!==s&&delete r[t]);return r})),Ur=o(((e,r)=>{for(let t in r)r[t]=e(r[t],+t,r);return r})),_r=o(((e,r)=>{const t=b(r);let n,s;t&&(n=0,s=[]);for(let n in r)e(r[n],n)||(t?s.push(+n):delete r[n]);if(t)for(const e of s)r.splice(e-n++,1);return r})),Dr=e=>{if(b(e))e.splice(0);else for(const r in e)delete e[r];return e},Fr=e=>{let r;for(const t in e)r=e[t],p(r)&&Fr(r);return Object.freeze(e)},Ir=e=>Object.freeze(e),Lr=o(((e,r)=>r.unshift(e))),qr=l(((e,r,t)=>{const n=e[0];return Nr(n,e.length<2?r:qr(e.slice(1),r,p(t[n])?t[n]:{}),t)})),Gr=e=>(...r)=>Cr(((e,r)=>e?e(r):e),e,r),Hr=e=>{const r=[],t=[],n=e.length;let s,c,o,l=0,i=0,u=!1,a=B(e),f=!1;for(l=0;l<n;l++)switch(s=e[l],s){case"{":if(!a){u=!0,i=l;break}case"}":if(!a){u=!1,r.push(""),t.push(e.slice(i+1,l));break}default:o=e[l+1],f="\\"===s,u||f&&("{"===o||"}"===o)||(c=r.length-1,c<0&&(r.push(""),c++),r[c]+=s),a=f}return e=>{const n=[],s=r.length-1;for(const c in r)l=+c,n.push(r[l]),l!==s&&n.push(De(t[l].split("."),e));return n.join("")}};export{he as F,fe as T,e as __,_ as add,Ee as all,$e as allPass,V as always,Pe as any,xe as anyPass,ce as append,Ne as assoc,Ce as assocPath,E as bind,Ze as both,pe as callFrom,be as callWith,qe as clone,Ge as cloneShallow,je as complement,C as compose,dr as composeAsync,Ve as concat,ve as cond,s as curry,o as curry2,l as curry3,Q as divide,wr as echo,rr as empty,A as eq,k as equals,ke as explore,nr as filter,J as find,K as findIndex,le as flat,ie as flatShallow,ue as flatTo,z as flip,Ye as forEach,yr as forEachAsync,gr as forEachSerial,He as freeze,Je as freezeShallow,Te as fromPairs,we as genBy,Hr as getTmpl,I as gt,q as gte,B as head,W as identity,v as ifElse,$ as includes,M as indexOf,Oe as intersection,er as isEmpty,R as isNil,We as join,ee as keys,Y as last,T as length,L as lt,G as lte,Xe as map,ar as mapKeys,sr as memoize,or as mergeDeep,ir as mergeDeepAdd,lr as mergeDeepX,cr as mergeShallow,mr as mirror,F as multiply,ge as noop,Z as not,Ar as notf,P as nth,Re as omit,Ae as once,ur as overProp,De as path,Fe as pathEq,_e as pathOr,Ie as pathsEq,Qe as pick,Me as pickBy,oe as prepend,ze as prop,Be as propEq,Ue as propsEq,Sr as push,vr as qappend,Nr as qassoc,qr as qassocPath,Dr as qempty,_r as qfilter,Fr as qfreeze,Ir as qfreezeShallow,Ur as qmap,Br as qmapKeys,Pr as qmergeDeep,xr as qmergeDeepAdd,$r as qmergeDeepX,zr as qmergeShallow,Lr as qprepend,Cr as qreduce,de as range,Ke as reduce,Or as reflect,tr as replace,Se as reverse,ye as sizeof,x as slice,kr as some,H as sort,ae as split,D as subtract,U as tail,w as take,se as tap,ne as test,y as toLower,te as toPairs,d as toUpper,X as trim,m as type,O as typeIs,Gr as uncurry,me as uniq,re as values,pr as waitAll,jr as waitTap,S as weakEq,N as when,fr as zip,hr as zipObj,br as zipWith};
