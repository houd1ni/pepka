const e=Symbol("Placeholder"),r=r=>{let t=0;for(const n of r)n!==e&&t++;return t},t=(r,t)=>{const n=r.length,s=r.slice(),c=t.length;let o=c,l=0;for(;o&&l<n;l++)s[l]===e&&(s[l]=t[c-o],o--);for(l=n;o;l++,o--)s[l]=t[c-o];return s},n=(e,s,c)=>{const o=e.length-s.length-r(c);if(o<1)return e(...t(s,c));{const r=(...r)=>n(e,t(s,c),r);return r.$args_left=o,r}},s=e=>(...t)=>e.length>r(t)?n(e,[],t):e(...t);function c(r){return function(t,n){const s=t===e;if(1===arguments.length&&s)throw new Error("Senseless placeholder usage.");return arguments.length>1?s?(r=>function(t){return t===e?r:r(t)})((e=>r(e,n))):r(t,n):e=>r(t,e)}}function o(e){return s(e)}const l=void 0,i=1/0,u=e=>typeof e,a=e=>null===e,f=e=>"number"==u(e),h=e=>Array.isArray(e),b=e=>"function"===u(e),g=e=>!a(e)&&"object"===u(e),p={u:"U",b:"B",n:"N",s:"S",f:"F"},j=Symbol(),y=e=>e.toLowerCase(),d=e=>e.toUpperCase(),m=e=>{const r=u(e);return"object"===r?a(e)?"Null":e.constructor.name:p[r[0]]+r.slice(1)},O=c(((e,r)=>m(r)===e)),w=e=>(...r)=>r[e],A=c(((e,r)=>e===r)),S=c(((e,r)=>e==r)),k=c(((e,r)=>{const t=m(e);if(A(t,m(r))&&(A(t,"Object")||A(t,"Array"))){if(a(e)||a(r))return A(e,r);if(A(e,r))return!0;for(const t of[e,r])for(const n in t)if(!(A(t,r)&&n in e||A(t,e)&&n in r&&k(e[n],r[n])))return!1;return!0}return A(e,r)})),v=s(((e,r,t,n)=>e(n)?r(n):t(n))),N=o(((e,r,t)=>v(e,r,W,t))),C=(...r)=>(...t)=>{let n,s=!0;for(let c=T(r)-1;c>-1;c--)s?(s=!1,n=r[c](...t)):n=n===e?r[c]():r[c](n);return n},E=c(((e,r)=>e.bind(r))),P=c(((e,r)=>r[e])),$=c(((e,r)=>{if((e=>"string"===u(e))(r))return r.includes(e);for(const t of r)if(k(t,e))return!0;return!1})),x=o(((e,r,t)=>t.slice(e,f(r)?r:i))),z=e=>c(((r,t)=>e(t,r))),B=P(0),U=x(1,i),_=c(((e,r)=>e+r)),D=c(((e,r)=>r-e)),F=c(((e,r)=>e*r)),I=c(((e,r)=>e>r)),L=c(((e,r)=>e<r)),q=c(((e,r)=>r>=e)),G=c(((e,r)=>r<=e)),H=c(((e,r)=>r.sort(e))),J=c(((e,r)=>r.find(e))),K=c(((e,r)=>r.findIndex(e))),M=c(((e,r)=>K(k(e),r))),Q=c(((e,r)=>e/r)),R=e=>a(e)||(e=>e===l)(e),T=e=>e.length,V=e=>()=>e,W=e=>e,X=e=>e.trim(),Y=e=>e[T(e)-1],Z=e=>!e,ee=e=>Object.keys(e),re=e=>Object.values(e),te=e=>Object.entries(e),ne=c(((e,r)=>e.test(r))),se=c(((e,r)=>(e(r),r))),ce=c(((e,r)=>[...r,e])),oe=c(((e,r)=>[...r,e])),le=e=>e.flat(i),ie=e=>e.flat(),ue=c(((e,r)=>r.flat(e))),ae=c(((e,r)=>r.split(e))),fe=V(!0),he=V(!1),be=c(((e,r)=>r(...e))),ge=()=>{},pe=s(((e,r,t)=>t[r](...e))),je=e=>(...r)=>{const t=e(...r),n=b(t);return!n||n&&t.$args_left<=0?Z(t):je(t)},ye=e=>{if("Object"===m(e)){let r=0;for(let t in e)r++;return r}return T(e)},de=c(((e,r)=>we(_(e),r-e))),me=e=>Pr(((e,r)=>$(r,e)?e:Cr(r,e)),[],e),Oe=c(((e,r)=>e.filter(z($)(r)))),we=c(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),Ae=e=>{let r,t=!1;return(...n)=>t?r:(t=!0,r=e(...n))},Se=e=>C((r=>Me(((t,n,s)=>Cr(e[r-s],t)),[],e)),_(-1),T)(e),ke=(e,r="log")=>se((t=>console[r](e,t))),ve=c(((e,r)=>{for(const[t,n]of e)if(t(r))return n(r)})),Ne=o(((e,r,t)=>({...t,[e]:r}))),Ce=o(((e,r,t)=>C((n=>Ne(n,T(e)<2?r:Ce(x(1,i,e),r,g(t[n])?t[n]:{}),t)),B)(e))),Ee=c(((e,r)=>r.every(e))),Pe=c(((e,r)=>r.some(e))),$e=c(((e,r)=>e.every((e=>e(r))))),xe=c(((e,r)=>e.some((e=>e(r))))),ze=c(((e,r)=>r[e])),Be=o(((e,r,t)=>k(t[e],r))),Ue=o(((e,r,t)=>k(r[e],t[e]))),_e=o(((e,r,t)=>T(r)?R(t)?e:C((n=>n in t?_e(e,x(1,i,r),t[n]):e),B)(r):t)),De=_e(l),Fe=o(((e,r,t)=>k(De(e,t),r))),Ie=o(((e,r,t)=>k(De(e,r),De(e,t)))),Le=C(v(k(j),he,fe),_e(j)),qe=/^(.*?)(8|16|32|64)(Clamped)?Array$/,Ge=(e,r=!1)=>{const t=m(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:Ye(C(Ge,w(0)),e);case"Object":if(r)return{...e};const n={};for(let r in e)n[r]=Ge(e[r]);return n;default:return qe.test(t)?e.constructor.from(e):e}},He=e=>Ge(e,!0),Je=e=>qr(Ge(e)),Ke=e=>Gr(Ge(e)),Me=o(((e,r,t)=>Pr(e,Ge(r),t))),Qe=c(((e,r)=>cr(e,r))),Re=c(((e,r)=>{const t={};for(const n of e)n in r&&(t[n]=r[n]);return t})),Te=c(((e,r)=>cr(((r,t)=>!$(t,e)),r))),Ve=e=>Object.fromEntries(e),We=c(((e,r)=>r.concat(e))),Xe=c(((e,r)=>r.join(e))),Ye=c(((e,r)=>r.map(e))),Ze=c(((e,r)=>Fr(e,He(r)))),er=c(((e,r)=>r.forEach(e))),rr=o(((e,r,t)=>r(t)&&e(t))),tr=e=>{switch(m(e)){case"String":case"Array":return 0==T(e);case"Object":for(const r in e)return!1;return!0;default:return null}},nr=e=>{switch(m(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return l}},sr=o(((e,r,t)=>t.replace(e,r))),cr=c(((e,r)=>h(r)?r.filter(e):Ir(e,{...r}))),or=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},lr=c(((e,r)=>Object.assign({},e,r))),ir=c(((e,r)=>xr(Ge(e),Ge(r)))),ur=c(((e,r)=>zr(Ge(e),Ge(r)))),ar=c(((e,r)=>Br(Ge(e),Ge(r)))),fr=o(((e,r,t)=>Ne(e,r(t[e]),t))),hr=c(((e,r)=>_r(e,Object.assign({},r)))),br=c(((e,r)=>Ye(((e,t)=>[e,r[t]]),e))),gr=c(((e,r)=>Me(((e,t,n)=>Ne(t,r[n],e)),{},e))),pr=o(((e,r,t)=>Ye(((r,n)=>e(r,t[n])),r))),jr=(()=>{const e=async(r,t,n)=>{n<t.length&&(await r(t[n]),await e(r,t,++n))};return c(((r,t)=>e(r,t,0)))})(),yr=e=>Promise.all(e),dr=c((async(e,r)=>(await e(r),r))),mr=c(((e,r)=>Promise.all(r.map(e)))),Or=(()=>{const e=async(r,t,n)=>~n?await e(r,[await r[n](...t)],--n):B(t);return(...r)=>(...t)=>e(r,t,r.length-1)})(),wr=W,Ar=W,Sr=W,kr=je,vr=ce,Nr=Pe,Cr=c(((e,r)=>(r.push(e),r))),Er=o(((e,r,t)=>(t[e]=r,t))),Pr=o(((e,r,t)=>t.reduce(e,r))),$r=o(((e,r,t)=>{for(let n in t)switch(m(t[n])){case"Array":if(e>1&&"Array"===m(r[n]))switch(e){case 2:const s=r[n],c=t[n];for(const r in c)s[r]?$r(e,s[r],c[r]):s[r]=c[r];break;case 3:r[n].push(...t[n])}else r[n]=t[n];break;case"Object":if("Object"===m(r[n])){$r(e,r[n],t[n]);break}default:r[n]=t[n]}return r})),xr=$r(1),zr=$r(2),Br=$r(3),Ur=c(((e,r)=>Object.assign(e,r))),_r=c(((e,r)=>{let t,n,s,c;for(t in e)t in r&&(n=e[t],[s,c]=b(n)?n(r[t],t,r):[n,r[t]],r[R(s)?t:s]=c,t!==s&&delete r[t]);return r})),Dr=c(((e,r)=>{for(let t in r)r[t]=e(r[t],+t,r);return r})),Fr=c(((e,r)=>Dr(e,r))),Ir=c(((e,r)=>{const t=h(r);let n,s;t&&(n=0,s=[]);for(let n in r)e(r[n],n)||(t?s.push(+n):delete r[n]);if(t)for(const e of s)r.splice(e-n++,1);return r})),Lr=e=>{if(h(e))e.splice(0);else for(const r in e)delete e[r];return e},qr=e=>{let r;for(const t in e)r=e[t],g(r)&&qr(r);return Object.freeze(e)},Gr=e=>Object.freeze(e),Hr=c(((e,r)=>r.unshift(e))),Jr=o(((e,r,t)=>{const n=e[0];return Er(n,e.length<2?r:Jr(e.slice(1),r,g(t[n])?t[n]:{}),t)})),Kr=e=>e.reverse(),Mr=c(((e,r)=>Ir(((r,t)=>!$(t,e)),r))),Qr=e=>(...r)=>Pr(((e,r)=>e?e(r):e),e,r),Rr=e=>{const r=[],t=[],n=e.length;let s,c,o,l=0,i=0,u=!1,a=B(e),f=!1;for(l=0;l<n;l++)switch(s=e[l],s){case"{":if(!a){u=!0,i=l;break}case"}":if(!a){u=!1,r.push(""),t.push(e.slice(i+1,l));break}default:o=e[l+1],f="\\"===s,u||f&&("{"===o||"}"===o)||(c=r.length-1,c<0&&(r.push(""),c++),r[c]+=s),a=f}return e=>{const n=[],s=r.length-1;for(const c in r)l=+c,n.push(r[l]),l!==s&&n.push(De(t[l].split("."),e));return n.join("")}};export{he as F,fe as T,e as __,_ as add,Ee as all,$e as allPass,V as always,Pe as any,xe as anyPass,ce as append,Ne as assoc,Ce as assocPath,E as bind,rr as both,pe as callFrom,be as callWith,Ge as clone,He as cloneShallow,je as complement,C as compose,Or as composeAsync,We as concat,ve as cond,s as curry,c as curry2,o as curry3,Q as divide,Sr as echo,nr as empty,A as eq,k as equals,ke as explore,cr as filter,J as find,K as findIndex,le as flat,ie as flatShallow,ue as flatTo,z as flip,er as forEach,mr as forEachAsync,jr as forEachSerial,Je as freeze,Ke as freezeShallow,Ve as fromPairs,we as genBy,Rr as getTmpl,I as gt,q as gte,B as head,W as identity,v as ifElse,$ as includes,M as indexOf,Oe as intersection,tr as isEmpty,R as isNil,Xe as join,ee as keys,Y as last,T as length,L as lt,G as lte,Ye as map,hr as mapKeys,Ze as mapObj,or as memoize,ir as mergeDeep,ar as mergeDeepAdd,ur as mergeDeepX,lr as mergeShallow,wr as mirror,F as multiply,ge as noop,Z as not,kr as notf,P as nth,Te as omit,Ae as once,fr as overProp,De as path,Fe as pathEq,Le as pathExists,_e as pathOr,Ie as pathsEq,Re as pick,Qe as pickBy,oe as prepend,ze as prop,Be as propEq,Ue as propsEq,vr as push,Cr as qappend,Er as qassoc,Jr as qassocPath,Lr as qempty,Ir as qfilter,qr as qfreeze,Gr as qfreezeShallow,Dr as qmap,_r as qmapKeys,Fr as qmapObj,xr as qmergeDeep,Br as qmergeDeepAdd,zr as qmergeDeepX,Ur as qmergeShallow,Mr as qomit,Hr as qprepend,Pr as qreduce,Kr as qreverse,de as range,Me as reduce,Ar as reflect,sr as replace,Se as reverse,ye as sizeof,x as slice,Nr as some,H as sort,ae as split,D as subtract,j as symbol,U as tail,w as take,se as tap,ne as test,y as toLower,te as toPairs,d as toUpper,X as trim,m as type,O as typeIs,Qr as uncurry,me as uniq,re as values,yr as waitAll,dr as waitTap,S as weakEq,N as when,br as zip,gr as zipObj,pr as zipWith};
