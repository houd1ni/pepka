"use strict";const e=Symbol("Placeholder"),r=r=>{let t=0;for(const s of r)s!==e&&t++;return t},t=(r,t)=>{const s=r.length,o=r.slice(),p=t.length;let n=p,x=0;for(;n&&x<s;x++)o[x]===e&&(o[x]=t[p-n],n--);for(x=s;n;x++,n--)o[x]=t[p-n];return o},s=(e,o,p)=>{const n=e.length-o.length-r(p);if(n<1)return e(...t(o,p));{const r=(...r)=>s(e,t(o,p),r);return r.$args_left=n,r}},o=e=>(...t)=>e.length>r(t)?s(e,[],t):e(...t);function p(r){return function(t,s){const o=t===e,p=arguments.length;if(1===p&&o)throw new Error("Senseless placeholder usage.");return p>1?o?(r=>function(t){return t===e?r:r(t)})((e=>r(e,s))):r(t,s):e=>r(t,e)}}function n(e){return o(e)}const x=void 0,c=1/0,a=e=>typeof e,l=e=>null===e,i=e=>"number"==a(e),u=e=>Array.isArray(e),f=e=>"function"===a(e),h=e=>!l(e)&&"object"===a(e),m={u:"U",b:"B",n:"N",s:"S",f:"F"},y=Symbol(),d=e=>{const r=a(e);return"object"===r?l(e)?"Null":e.constructor.name:m[r[0]]+r.slice(1)},g=p(((e,r)=>d(r)===e)),b=e=>(...r)=>r[e],q=p(((e,r)=>e===r)),w=p(((e,r)=>e==r)),j=p(((e,r)=>{const t=d(e);if(q(t,d(r))&&(q(t,"Object")||q(t,"Array"))){if(l(e)||l(r))return q(e,r);if(q(e,r))return!0;for(const t of[e,r])for(const s in t)if(!(q(t,r)&&s in e||q(t,e)&&s in r&&j(e[s],r[s])))return!1;return!0}return q(e,r)})),O=o(((e,r,t,s)=>e(s)?r(s):t(s))),A=n(((e,r,t)=>O(e,r,M,t))),S=(...r)=>(...t)=>{let s,o=!0;for(let p=H(r)-1;p>-1;p--)o?(o=!1,s=r[p](...t)):s=s===e?r[p]():r[p](s);return s},E=p(((e,r)=>e.bind(r))),k=p(((e,r)=>r[e])),z=p(((e,r)=>{if((e=>"string"===a(e))(r))return r.includes(e);for(const t of r)if(j(t,e))return!0;return!1})),v=n(((e,r,t)=>t.slice(e,i(r)?r:c))),P=e=>p(((r,t)=>e(t,r))),D=k(0),N=v(1,c),B=p(((e,r)=>e+r)),T=p(((e,r)=>r-e)),_=p(((e,r)=>e*r)),C=p(((e,r)=>e>r)),F=p(((e,r)=>e<r)),I=p(((e,r)=>r>=e)),U=p(((e,r)=>r<=e)),$=p(((e,r)=>r.sort(e))),K=p(((e,r)=>r.find(e))),L=p(((e,r)=>r.findIndex(e))),W=p(((e,r)=>L(j(e),r))),X=p(((e,r)=>e/r)),G=e=>l(e)||(e=>e===x)(e),H=e=>e.length,J=e=>()=>e,M=e=>e,Q=e=>!e,R=p(((e,r)=>e.test(r))),V=p(((e,r)=>(e(r),r))),Y=p(((e,r)=>[...r,e])),Z=p(((e,r)=>[...r,e])),ee=p(((e,r)=>r.flat(e))),re=p(((e,r)=>r.split(e))),te=J(!0),se=J(!1),oe=p(((e,r)=>r(...e))),pe=o(((e,r,t)=>t[r](...e))),ne=e=>(...r)=>{const t=e(...r),s=f(t);return!s||s&&t.$args_left<=0?Q(t):ne(t)},xe=p(((e,r)=>ae(B(e),r-e))),ce=p(((e,r)=>e.filter(P(z)(r)))),ae=p(((e,r)=>[...Array(r)].map(((r,t)=>e(t))))),le=p(((e,r)=>{for(const[t,s]of e)if(t(r))return s(r)})),ie=n(((e,r,t)=>({...t,[e]:r}))),ue=n(((e,r,t)=>S((s=>ie(s,H(e)<2?r:ue(v(1,c,e),r,h(t[s])?t[s]:{}),t)),D)(e))),fe=p(((e,r)=>r.every(e))),he=p(((e,r)=>r.some(e))),me=p(((e,r)=>e.every((e=>e(r))))),ye=p(((e,r)=>e.some((e=>e(r))))),de=p(((e,r)=>r[e])),ge=n(((e,r,t)=>j(t[e],r))),be=n(((e,r,t)=>j(r[e],t[e]))),qe=n(((e,r,t)=>H(r)?G(t)?e:S((s=>s in t?qe(e,v(1,c,r),t[s]):e),D)(r):t)),we=qe(x),je=n(((e,r,t)=>j(we(e,t),r))),Oe=n(((e,r,t)=>j(we(e,r),we(e,t)))),Ae=S(O(j(y),se,te),qe(y)),Se=/^(.*?)(8|16|32|64)(Clamped)?Array$/,Ee=(e,r=!1)=>{const t=d(e);switch(t){case"Null":case"String":case"Number":case"Boolean":case"Symbol":return e;case"Array":return r?[...e]:Te(S(Ee,b(0)),e);case"Object":if(r)return{...e};const s={};for(let r in e)s[r]=Ee(e[r]);return s;default:return Se.test(t)?e.constructor.from(e):e}},ke=e=>Ee(e,!0),ze=n(((e,r,t)=>xr(e,Ee(r),t))),ve=p(((e,r)=>Ue(e,r))),Pe=p(((e,r)=>{const t={};for(const s of e)s in r&&(t[s]=r[s]);return t})),De=p(((e,r)=>Ue(((r,t)=>!z(t,e)),r))),Ne=p(((e,r)=>r.concat(e))),Be=p(((e,r)=>r.join(e))),Te=p(((e,r)=>r.map(e))),_e=p(((e,r)=>mr(e,ke(r)))),Ce=p(((e,r)=>r.forEach(e))),Fe=n(((e,r,t)=>r(t)&&e(t))),Ie=n(((e,r,t)=>t.replace(e,r))),Ue=p(((e,r)=>u(r)?r.filter(e):yr(e,{...r}))),$e=p(((e,r)=>Object.assign({},e,r))),Ke=p(((e,r)=>ar(Ee(e),Ee(r)))),Le=p(((e,r)=>lr(Ee(e),Ee(r)))),We=p(((e,r)=>ir(Ee(e),Ee(r)))),Xe=n(((e,r,t)=>ie(e,r(t[e]),t))),Ge=p(((e,r)=>fr(e,Object.assign({},r)))),He=p(((e,r)=>Te(((e,t)=>[e,r[t]]),e))),Je=p(((e,r)=>ze(((e,t,s)=>ie(t,r[s],e)),{},e))),Me=n(((e,r,t)=>Te(((r,s)=>e(r,t[s])),r))),Qe=(()=>{const e=async(r,t,s)=>{s<t.length&&(await r(t[s]),await e(r,t,++s))};return p(((r,t)=>e(r,t,0)))})(),Re=p((async(e,r)=>(await e(r),r))),Ve=p(((e,r)=>Promise.all(r.map(e)))),Ye=(()=>{const e=async(r,t,s)=>~s?await e(r,[await r[s](...t)],--s):D(t);return(...r)=>(...t)=>e(r,t,r.length-1)})(),Ze=M,er=M,rr=M,tr=ne,sr=Y,or=he,pr=p(((e,r)=>(r.push(e),r))),nr=n(((e,r,t)=>(t[e]=r,t))),xr=n(((e,r,t)=>t.reduce(e,r))),cr=n(((e,r,t)=>{for(let s in t)switch(d(t[s])){case"Array":if(e>1&&"Array"===d(r[s]))switch(e){case 2:const o=r[s],p=t[s];for(const r in p)o[r]?cr(e,o[r],p[r]):o[r]=p[r];break;case 3:r[s].push(...t[s])}else r[s]=t[s];break;case"Object":if("Object"===d(r[s])){cr(e,r[s],t[s]);break}default:r[s]=t[s]}return r})),ar=cr(1),lr=cr(2),ir=cr(3),ur=p(((e,r)=>Object.assign(e,r))),fr=p(((e,r)=>{let t,s,o,p;for(t in e)t in r&&(s=e[t],[o,p]=f(s)?s(r[t],t,r):[s,r[t]],r[G(o)?t:o]=p,t!==o&&delete r[t]);return r})),hr=p(((e,r)=>{for(let t in r)r[t]=e(r[t],+t,r);return r})),mr=p(((e,r)=>hr(e,r))),yr=p(((e,r)=>{const t=u(r);let s,o;t&&(s=0,o=[]);for(let s in r)e(r[s],s)||(t?o.push(+s):delete r[s]);if(t)for(const e of o)r.splice(e-s++,1);return r})),dr=e=>{let r;for(const t in e)r=e[t],h(r)&&dr(r);return Object.freeze(e)},gr=e=>Object.freeze(e),br=p(((e,r)=>r.unshift(e))),qr=n(((e,r,t)=>{const s=e[0];return nr(s,e.length<2?r:qr(e.slice(1),r,h(t[s])?t[s]:{}),t)})),wr=p(((e,r)=>yr(((r,t)=>!z(t,e)),r)));exports.F=se,exports.T=te,exports.__=e,exports.add=B,exports.all=fe,exports.allPass=me,exports.always=J,exports.any=he,exports.anyPass=ye,exports.append=Y,exports.assoc=ie,exports.assocPath=ue,exports.bind=E,exports.both=Fe,exports.callFrom=pe,exports.callWith=oe,exports.clone=Ee,exports.cloneShallow=ke,exports.complement=ne,exports.compose=S,exports.composeAsync=Ye,exports.concat=Ne,exports.cond=le,exports.curry=o,exports.curry2=p,exports.curry3=n,exports.divide=X,exports.echo=rr,exports.empty=e=>{switch(d(e)){case"String":return"";case"Object":return{};case"Array":return[];default:return x}},exports.eq=q,exports.equals=j,exports.explore=(e,r="log")=>V((t=>console[r](e,t))),exports.filter=Ue,exports.find=K,exports.findIndex=L,exports.flat=e=>e.flat(c),exports.flatShallow=e=>e.flat(),exports.flatTo=ee,exports.flip=P,exports.forEach=Ce,exports.forEachAsync=Ve,exports.forEachSerial=Qe,exports.freeze=e=>dr(Ee(e)),exports.freezeShallow=e=>gr(Ee(e)),exports.fromPairs=e=>Object.fromEntries(e),exports.genBy=ae,exports.getTmpl=e=>{const r=[],t=[],s=e.length;let o,p,n,x=0,c=0,a=!1,l=D(e),i=!1;for(x=0;x<s;x++)switch(o=e[x],o){case"{":if(!l){a=!0,c=x;break}case"}":if(!l){a=!1,r.push(""),t.push(e.slice(c+1,x));break}default:n=e[x+1],i="\\"===o,a||i&&("{"===n||"}"===n)||(p=r.length-1,p<0&&(r.push(""),p++),r[p]+=o),l=i}return e=>{const s=[],o=r.length-1;for(const p in r)x=+p,s.push(r[x]),x!==o&&s.push(we(t[x].split("."),e));return s.join("")}},exports.gt=C,exports.gte=I,exports.head=D,exports.identity=M,exports.ifElse=O,exports.includes=z,exports.indexOf=W,exports.intersection=ce,exports.isEmpty=e=>{switch(d(e)){case"String":case"Array":return 0==H(e);case"Object":for(const r in e)return!1;return!0;default:return null}},exports.isNil=G,exports.join=Be,exports.keys=e=>Object.keys(e),exports.last=e=>e[H(e)-1],exports.length=H,exports.lt=F,exports.lte=U,exports.map=Te,exports.mapKeys=Ge,exports.mapObj=_e,exports.memoize=e=>{let r,t=!1;return()=>t?r:(t=!0,r=e())},exports.mergeDeep=Ke,exports.mergeDeepAdd=We,exports.mergeDeepX=Le,exports.mergeShallow=$e,exports.mirror=Ze,exports.multiply=_,exports.noop=()=>{},exports.not=Q,exports.notf=tr,exports.nth=k,exports.omit=De,exports.once=e=>{let r,t=!1;return(...s)=>t?r:(t=!0,r=e(...s))},exports.overProp=Xe,exports.path=we,exports.pathEq=je,exports.pathExists=Ae,exports.pathOr=qe,exports.pathsEq=Oe,exports.pick=Pe,exports.pickBy=ve,exports.prepend=Z,exports.prop=de,exports.propEq=ge,exports.propsEq=be,exports.push=sr,exports.qappend=pr,exports.qassoc=nr,exports.qassocPath=qr,exports.qempty=e=>{if(u(e))e.splice(0);else for(const r in e)delete e[r];return e},exports.qfilter=yr,exports.qfreeze=dr,exports.qfreezeShallow=gr,exports.qmap=hr,exports.qmapKeys=fr,exports.qmapObj=mr,exports.qmergeDeep=ar,exports.qmergeDeepAdd=ir,exports.qmergeDeepX=lr,exports.qmergeShallow=ur,exports.qomit=wr,exports.qprepend=br,exports.qreduce=xr,exports.qreverse=e=>e.reverse(),exports.range=xe,exports.reduce=ze,exports.reflect=er,exports.replace=Ie,exports.reverse=e=>S((r=>ze(((t,s,o)=>pr(e[r-o],t)),[],e)),B(-1),H)(e),exports.sizeof=e=>{if("Object"===d(e)){let r=0;for(let t in e)r++;return r}return H(e)},exports.slice=v,exports.some=or,exports.sort=$,exports.split=re,exports.subtract=T,exports.symbol=y,exports.tail=N,exports.take=b,exports.tap=V,exports.test=R,exports.toLower=e=>e.toLowerCase(),exports.toPairs=e=>Object.entries(e),exports.toUpper=e=>e.toUpperCase(),exports.trim=e=>e.trim(),exports.type=d,exports.typeIs=g,exports.uncurry=e=>(...r)=>xr(((e,r)=>e?e(r):e),e,r),exports.uniq=e=>xr(((e,r)=>z(r,e)?e:pr(r,e)),[],e),exports.values=e=>Object.values(e),exports.waitAll=e=>Promise.all(e),exports.waitTap=Re,exports.weakEq=w,exports.when=A,exports.zip=He,exports.zipObj=Je,exports.zipWith=Me;
