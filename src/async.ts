import { curry2 } from "./curry"
import { head } from "./safe"
import { AnyFunc } from "./types"

/** One promise waits for another. */
export const forEachSerial = (() => {
  const pipe = async (fn: AnyFunc, items: any[], i: number) => {
    if(i<items.length) {
      await fn(items[i])
      await pipe(fn, items, ++i)
    }
  }
  return curry2(
    (fn: AnyFunc, items: any[]) => pipe(fn, items, 0)
  )
})()
/** Promise.all wrapper for functional pipelining. */
export const waitAll = <T>(promises: Promise<T>[]) => Promise.all<T>(promises)
/** Waits for a Promise that been generated by the first arg, then returns an untoched value. Types T.
 * @param {AnyFunc<Promise>} fn - function to wait.
 * @param {T} s - any value to tap and return back
 * @returns {T}
 */
export const waitTap = curry2(async (fn: AnyFunc<Promise<any>>, s: any) => { await fn(s); return s })
/** Waits for all promises mapped by the fn. */
export const forEachAsync = curry2(
  (fn: (item: any) => Promise<any>, items: any[]) => Promise.all(items.map(fn))
)
/** The same as compose, but waits for promises in chains and returns a Promise.  */
export const composeAsync = (() => {
  const pipe = async (fns: AnyFunc[], input: any[], i: number): Promise<any> =>
    ~i ? await pipe(fns, [await fns[i](...input)], --i) : head(input)
  return <T = any>(...fns: AnyFunc[]) =>
    (...input: any[]) => pipe(fns, input, fns.length-1) as Promise<T>
})()